<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>3D Weather</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    overflow: hidden;
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: #0a0a1a;
    color: #fff;
  }

  #canvas-container {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    z-index: 0;
  }

  canvas { display: block; }

  /* Loading screen */
  #loading {
    position: fixed;
    inset: 0;
    z-index: 1000;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: #0a0a1a;
    transition: opacity 0.8s ease;
  }

  #loading.fade-out { opacity: 0; pointer-events: none; }

  #loading h1 {
    font-size: 2rem;
    font-weight: 300;
    letter-spacing: 0.3em;
    margin-bottom: 1.5rem;
    text-transform: uppercase;
  }

  .loader {
    width: 48px; height: 48px;
    border: 3px solid rgba(255,255,255,0.15);
    border-top-color: #fff;
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  /* Weather overlay */
  #weather-overlay {
    position: fixed;
    z-index: 10;
    bottom: 0; left: 0;
    width: 100%;
    padding: 2rem 2.5rem;
    background: linear-gradient(to top, rgba(0,0,0,0.55) 0%, rgba(0,0,0,0.25) 60%, transparent 100%);
    pointer-events: none;
    opacity: 0;
    transition: opacity 1s ease;
  }

  #weather-overlay.visible { opacity: 1; }

  .weather-header {
    display: flex;
    align-items: baseline;
    gap: 1rem;
    margin-bottom: 0.5rem;
  }

  .city-name {
    font-size: 1.1rem;
    font-weight: 600;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    opacity: 0.7;
  }

  .weather-desc {
    font-size: 0.9rem;
    font-weight: 300;
    opacity: 0.6;
    letter-spacing: 0.05em;
  }

  .temperature {
    font-size: 5rem;
    font-weight: 200;
    line-height: 1;
    letter-spacing: -0.03em;
    margin-bottom: 0.75rem;
    text-shadow: 0 2px 20px rgba(0,0,0,0.3);
  }

  .temperature sup {
    font-size: 2rem;
    vertical-align: super;
    font-weight: 300;
  }

  .stats-row {
    display: flex;
    gap: 2.5rem;
    flex-wrap: wrap;
  }

  .stat {
    display: flex;
    flex-direction: column;
    gap: 0.15rem;
  }

  .stat-label {
    font-size: 0.65rem;
    text-transform: uppercase;
    letter-spacing: 0.15em;
    opacity: 0.45;
    font-weight: 500;
  }

  .stat-value {
    font-size: 1rem;
    font-weight: 300;
    opacity: 0.85;
  }

  /* Top-right timestamp */
  #timestamp {
    position: fixed;
    top: 1.5rem;
    right: 2rem;
    z-index: 10;
    font-size: 0.7rem;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    opacity: 0;
    transition: opacity 1s ease;
  }

  #timestamp.visible { opacity: 0.4; }

  /* Error display */
  #error-msg {
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    z-index: 100;
    background: rgba(180,40,40,0.9);
    padding: 1.5rem 2.5rem;
    border-radius: 8px;
    display: none;
    text-align: center;
    font-size: 0.9rem;
  }

  /* City picker dropdown */
  #city-picker-container {
    position: fixed;
    top: 1.5rem;
    left: 2rem;
    z-index: 20;
    opacity: 0;
    transition: opacity 1s ease;
  }

  #city-picker-container.visible { opacity: 1; }

  #city-picker {
    appearance: none;
    -webkit-appearance: none;
    background: rgba(0, 0, 0, 0.45);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    color: #fff;
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    font-size: 0.8rem;
    font-weight: 400;
    letter-spacing: 0.1em;
    padding: 0.6rem 2.2rem 0.6rem 1rem;
    border: 1px solid rgba(255, 255, 255, 0.12);
    border-radius: 6px;
    cursor: pointer;
    outline: none;
    transition: background 0.3s ease, border-color 0.3s ease;
    pointer-events: all;
  }

  #city-picker:hover {
    background: rgba(0, 0, 0, 0.6);
    border-color: rgba(255, 255, 255, 0.25);
  }

  #city-picker:focus {
    border-color: rgba(255, 255, 255, 0.35);
  }

  /* Custom dropdown arrow */
  #city-picker-container::after {
    content: '\25BE';
    position: absolute;
    right: 0.8rem;
    top: 50%;
    transform: translateY(-50%);
    color: rgba(255, 255, 255, 0.5);
    font-size: 0.75rem;
    pointer-events: none;
  }

  #city-picker option {
    background: #1a1a2e;
    color: #fff;
    padding: 0.4rem;
  }

  /* Fade transition for weather overlay on city switch */
  #weather-overlay.switching {
    opacity: 0.3 !important;
    transition: opacity 0.3s ease;
  }

  @media (max-width: 600px) {
    .temperature { font-size: 3.5rem; }
    #weather-overlay { padding: 1.5rem; }
    .stats-row { gap: 1.5rem; }
    #city-picker-container { left: 1rem; top: 1rem; }
    #city-picker { font-size: 0.72rem; padding: 0.5rem 2rem 0.5rem 0.8rem; }
  }
</style>
</head>
<body>

<div id="loading">
  <h1>3D Weather</h1>
  <div class="loader"></div>
</div>

<div id="canvas-container"></div>

<div id="city-picker-container">
  <select id="city-picker" aria-label="Select city">
    <option value="amsterdam">Amsterdam</option>
    <option value="london">London</option>
    <option value="new-york">New York</option>
    <option value="tokyo">Tokyo</option>
    <option value="sydney">Sydney</option>
    <option value="paris">Paris</option>
    <option value="dubai">Dubai</option>
    <option value="singapore">Singapore</option>
    <option value="sao-paulo">S&#227;o Paulo</option>
    <option value="cairo">Cairo</option>
    <option value="mumbai">Mumbai</option>
    <option value="toronto">Toronto</option>
    <option value="berlin">Berlin</option>
    <option value="moscow">Moscow</option>
    <option value="beijing">Beijing</option>
    <option value="los-angeles">Los Angeles</option>
    <option value="cape-town">Cape Town</option>
    <option value="mexico-city">Mexico City</option>
    <option value="seoul">Seoul</option>
    <option value="rome">Rome</option>
    <option value="istanbul">Istanbul</option>
    <option value="bangkok">Bangkok</option>
    <option value="stockholm">Stockholm</option>
    <option value="zurich">Zurich</option>
    <option value="tehran">Tehran</option>
  </select>
</div>

<div id="timestamp"></div>

<div id="weather-overlay">
  <div class="weather-header">
    <span class="city-name">Amsterdam</span>
    <span class="weather-desc" id="weather-desc">--</span>
  </div>
  <div class="temperature" id="temperature">--<sup>&deg;C</sup></div>
  <div class="stats-row">
    <div class="stat">
      <span class="stat-label">Feels Like</span>
      <span class="stat-value" id="feels-like">--</span>
    </div>
    <div class="stat">
      <span class="stat-label">Humidity</span>
      <span class="stat-value" id="humidity">--</span>
    </div>
    <div class="stat">
      <span class="stat-label">Wind</span>
      <span class="stat-value" id="wind">--</span>
    </div>
  </div>
</div>

<div id="error-msg"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
(function () {
  "use strict";

  // ---------------------------------------------------------------------------
  // Configuration — cities and API
  // ---------------------------------------------------------------------------
  const CITIES = {
    "amsterdam":   { name: "Amsterdam",    lat: 52.3676, lon:   4.9041, tz: "Europe/Amsterdam" },
    "london":      { name: "London",       lat: 51.5074, lon:  -0.1278, tz: "Europe/London" },
    "new-york":    { name: "New York",     lat: 40.7128, lon: -74.0060, tz: "America/New_York" },
    "tokyo":       { name: "Tokyo",        lat: 35.6762, lon: 139.6503, tz: "Asia/Tokyo" },
    "sydney":      { name: "Sydney",       lat: -33.8688, lon: 151.2093, tz: "Australia/Sydney" },
    "paris":       { name: "Paris",        lat: 48.8566, lon:   2.3522, tz: "Europe/Paris" },
    "dubai":       { name: "Dubai",        lat: 25.2048, lon:  55.2708, tz: "Asia/Dubai" },
    "singapore":   { name: "Singapore",    lat:  1.3521, lon: 103.8198, tz: "Asia/Singapore" },
    "sao-paulo":   { name: "São Paulo",    lat: -23.5505, lon: -46.6333, tz: "America/Sao_Paulo" },
    "cairo":       { name: "Cairo",        lat: 30.0444, lon:  31.2357, tz: "Africa/Cairo" },
    "mumbai":      { name: "Mumbai",       lat: 19.0760, lon:  72.8777, tz: "Asia/Kolkata" },
    "toronto":     { name: "Toronto",      lat: 43.6532, lon: -79.3832, tz: "America/Toronto" },
    "berlin":      { name: "Berlin",       lat: 52.5200, lon:  13.4050, tz: "Europe/Berlin" },
    "moscow":      { name: "Moscow",       lat: 55.7558, lon:  37.6173, tz: "Europe/Moscow" },
    "beijing":     { name: "Beijing",      lat: 39.9042, lon: 116.4074, tz: "Asia/Shanghai" },
    "los-angeles": { name: "Los Angeles",  lat: 33.9425, lon: -118.2551, tz: "America/Los_Angeles" },
    "cape-town":   { name: "Cape Town",    lat: -33.9249, lon:  18.4241, tz: "Africa/Johannesburg" },
    "mexico-city": { name: "Mexico City",  lat: 19.4326, lon: -99.1332, tz: "America/Mexico_City" },
    "seoul":       { name: "Seoul",        lat: 37.5665, lon: 126.9780, tz: "Asia/Seoul" },
    "rome":        { name: "Rome",         lat: 41.9028, lon:  12.4964, tz: "Europe/Rome" },
    "istanbul":    { name: "Istanbul",     lat: 41.0082, lon:  28.9784, tz: "Europe/Istanbul" },
    "bangkok":     { name: "Bangkok",      lat: 13.7563, lon: 100.5018, tz: "Asia/Bangkok" },
    "stockholm":   { name: "Stockholm",    lat: 59.3293, lon:  18.0686, tz: "Europe/Stockholm" },
    "zurich":      { name: "Zurich",       lat: 47.3769, lon:   8.5417, tz: "Europe/Zurich" },
    "tehran":      { name: "Tehran",       lat: 35.6892, lon:  51.3890, tz: "Asia/Tehran" },
  };

  function detectCityFromTimezone(tz) {
    // 1. Exact timezone match
    for (const [key, city] of Object.entries(CITIES)) {
      if (city.tz === tz) return key;
    }
    // 2. City name embedded in timezone string (e.g. "America/New_York" ~ "New York")
    const tzCity = tz.split('/').pop().replace(/_/g, ' ').toLowerCase();
    for (const [key, city] of Object.entries(CITIES)) {
      if (city.name.toLowerCase() === tzCity) return key;
    }
    // 3. Continent prefix fallback
    const prefix = tz.split('/')[0];
    const fallbacks = {
      'America': 'new-york', 'Europe': 'london', 'Asia': 'tokyo',
      'Australia': 'sydney',  'Pacific': 'sydney', 'Africa': 'cairo',
      'Atlantic': 'london',   'Indian': 'dubai',
    };
    return fallbacks[prefix] || 'amsterdam';
  }

  let currentCityKey = "amsterdam";

  function buildApiUrl(cityKey) {
    const city = CITIES[cityKey];
    return "https://api.open-meteo.com/v1/forecast" +
      "?latitude=" + city.lat + "&longitude=" + city.lon +
      "&current=temperature_2m,relative_humidity_2m,apparent_temperature,weather_code,wind_speed_10m" +
      "&timezone=" + encodeURIComponent(city.tz);
  }

  const WMO_DESCRIPTIONS = {
    0: "Clear sky",
    1: "Mainly clear", 2: "Partly cloudy", 3: "Overcast",
    45: "Fog", 48: "Depositing rime fog",
    51: "Light drizzle", 53: "Moderate drizzle", 55: "Dense drizzle",
    56: "Light freezing drizzle", 57: "Dense freezing drizzle",
    61: "Slight rain", 63: "Moderate rain", 65: "Heavy rain",
    66: "Light freezing rain", 67: "Heavy freezing rain",
    71: "Slight snowfall", 73: "Moderate snowfall", 75: "Heavy snowfall",
    77: "Snow grains",
    80: "Slight rain showers", 81: "Moderate rain showers", 82: "Violent rain showers",
    85: "Slight snow showers", 86: "Heavy snow showers",
    95: "Thunderstorm", 96: "Thunderstorm with slight hail", 99: "Thunderstorm with heavy hail",
  };

  // Map WMO code to a condition category
  function classifyWeather(code) {
    if (code === 0) return "clear";
    if (code <= 3) return "cloudy";
    if (code === 45 || code === 48) return "fog";
    if ((code >= 51 && code <= 67) || (code >= 80 && code <= 82)) return "rain";
    if ((code >= 71 && code <= 77) || (code >= 85 && code <= 86)) return "snow";
    if (code >= 95) return "thunder";
    return "cloudy";
  }

  // ---------------------------------------------------------------------------
  // Three.js scene setup
  // ---------------------------------------------------------------------------
  const container = document.getElementById("canvas-container");
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(60, innerWidth / innerHeight, 0.1, 1000);
  camera.position.set(0, 6, 28);
  camera.lookAt(0, 4, 0);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setSize(innerWidth, innerHeight);
  renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
  renderer.shadowMap.enabled = true;
  renderer.shadowMap.type = THREE.PCFSoftShadowMap;
  renderer.toneMapping = THREE.ACESFilmicToneMapping;
  renderer.toneMappingExposure = 1.0;
  container.appendChild(renderer.domElement);

  // ---------------------------------------------------------------------------
  // Fog (will be adjusted per weather)
  // ---------------------------------------------------------------------------
  scene.fog = new THREE.FogExp2(0x8faabe, 0.008);

  // ---------------------------------------------------------------------------
  // Lights
  // ---------------------------------------------------------------------------
  const ambientLight = new THREE.AmbientLight(0x8899bb, 0.4);
  scene.add(ambientLight);

  const dirLight = new THREE.DirectionalLight(0xffeedd, 1.0);
  dirLight.position.set(15, 25, 20);
  dirLight.castShadow = true;
  dirLight.shadow.mapSize.set(1024, 1024);
  dirLight.shadow.camera.left = -40;
  dirLight.shadow.camera.right = 40;
  dirLight.shadow.camera.top = 30;
  dirLight.shadow.camera.bottom = -10;
  dirLight.shadow.camera.near = 1;
  dirLight.shadow.camera.far = 80;
  scene.add(dirLight);

  const hemiLight = new THREE.HemisphereLight(0xaaccff, 0x444422, 0.5);
  scene.add(hemiLight);

  // ---------------------------------------------------------------------------
  // Ground / water plane
  // ---------------------------------------------------------------------------
  const waterGeo = new THREE.PlaneGeometry(200, 200, 64, 64);
  const waterMat = new THREE.MeshStandardMaterial({
    color: 0x1a3040,
    metalness: 0.6,
    roughness: 0.35,
    transparent: true,
    opacity: 0.85,
  });
  const water = new THREE.Mesh(waterGeo, waterMat);
  water.rotation.x = -Math.PI / 2;
  water.position.y = -0.5;
  water.receiveShadow = true;
  scene.add(water);

  // Animate water vertices
  const waterPosAttr = waterGeo.attributes.position;
  const waterOrigY = new Float32Array(waterPosAttr.count);
  for (let i = 0; i < waterPosAttr.count; i++) {
    waterOrigY[i] = waterPosAttr.getZ(i); // plane is XY before rotation, Z is "up"
  }

  // ---------------------------------------------------------------------------
  // Amsterdam skyline — procedural buildings
  // ---------------------------------------------------------------------------
  const buildingsGroup = new THREE.Group();
  scene.add(buildingsGroup);

  // Road surface — permanent dark asphalt so lamp pools and headlight beams
  // have a surface to render against in every city (additive blending needs geometry behind it)
  const roadMesh = new THREE.Mesh(
    new THREE.PlaneGeometry(82, 7),
    new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.95, metalness: 0.05 })
  );
  roadMesh.rotation.x = -Math.PI / 2;
  roadMesh.position.set(0, 0.01, -11); // centred on the car/lamp zone (z -7.5 to -14.5)
  roadMesh.receiveShadow = true;
  scene.add(roadMesh);

  // Palette for buildings
  const buildingColors = [0x2a2a35, 0x33333f, 0x3a2a28, 0x28303a, 0x352a2a, 0x2f3530];

  // Mexico City gunfight flash materials
  const mxFlashMats = [];

  // Snow cap roof tracking
  const buildingRoofs = [];
  const snowCapsGroup = new THREE.Group();
  scene.add(snowCapsGroup);
  const snowCapMats = [];

  // Neon signs
  const NEON_CITIES = new Set(['tokyo', 'new-york', 'bangkok', 'dubai', 'seoul', 'singapore', 'los-angeles', 'berlin']);
  const NEON_PALETTE = [0xff0066, 0x00ffcc, 0xff6600, 0x00aaff, 0xff00ff, 0xffff00, 0x00ff44, 0xff2244];
  const neonsGroup = new THREE.Group();
  scene.add(neonsGroup);
  const neonSignData = [];

  // Street lamps
  const lampsGroup = new THREE.Group();
  scene.add(lampsGroup);
  const lampBulbMats = [];
  const lampPoolMats = [];

  // Flags
  let currentWindSpeed = 5;
  const FLAG_COLORS = [0xcc2222, 0x2244cc, 0xeebb22, 0x228833, 0xffffff, 0xcc8822, 0xdd3355];
  const CITY_FLAG_POLES = {
    'amsterdam':   [[-5,11,-14],[10,23,-14],[-10,9,-10]],
    'london':      [[10,33,-15],[-28,22,-10]],
    'paris':       [[-4,10,-17],[12,19,-16]],
    'berlin':      [[-18,15,-17],[0,10,-13]],
    'new-york':    [[-12,27,-24],[0,44,-18],[12,33,-20]],
    'los-angeles': [[-14,18,-46],[16,18,-17]],
    'toronto':     [[0,56,-17],[-14,8,-18]],
    'tokyo':       [[-10,36,-17],[12,54,-24]],
    'beijing':     [[0,30,-22],[-7,30,-22]],
    'seoul':       [[-8,57,-18],[8,47,-20]],
    'bangkok':     [[0,27,-16],[-13,12,-18]],
    'dubai':       [[0,66,-22],[-14,15,-18]],
    'singapore':   [[-7,33,-20],[0,33,-20],[7,33,-20]],
    'mumbai':      [[0,22,-14],[-24,11,-10]],
    'cairo':       [[16,30,-15],[-12,22,-16]],
    'sydney':      [[-30,22,-1],[-16,22,-1]],
  };
  const defaultFlagPoles = [[-5,7,-11],[5,7,-11],[18,5,-10],[-18,5,-10]];
  const flagsGroup = new THREE.Group();
  scene.add(flagsGroup);
  const flagData = [];

  function createBuilding(x, z, w, h, d, color) {
    buildingRoofs.push({ x, z, w, h, d });
    const geo = new THREE.BoxGeometry(w, h, d);
    const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.8, metalness: 0.15 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, h / 2 - 0.5, z);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    return mesh;
  }

  // Gabled roof (triangular prism) typical of Amsterdam canal houses
  function createGabledRoof(x, baseY, z, w, d, color) {
    const shape = new THREE.Shape();
    const halfW = w / 2;
    const roofH = w * 0.45;
    shape.moveTo(-halfW, 0);
    shape.lineTo(halfW, 0);
    shape.lineTo(0, roofH);
    shape.closePath();
    const extrudeSettings = { depth: d, bevelEnabled: false };
    const geo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
    const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.75, metalness: 0.1 });
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x, baseY, z - d / 2);
    mesh.castShadow = true;
    return mesh;
  }

  // Window emissive dots
  const allWindowMats = []; // collect all lit-window materials for night brightening
  function addWindows(parent, x, z, w, h, d) {
    const winGeo = new THREE.PlaneGeometry(0.25, 0.35);
    const winMatLit = new THREE.MeshStandardMaterial({ color: 0xffdd88, emissive: 0xffcc66, emissiveIntensity: 0.6, roughness: 1 });
    allWindowMats.push(winMatLit);
    const winMatDark = new THREE.MeshStandardMaterial({ color: 0x111122, roughness: 1 });
    const rows = Math.max(1, Math.floor((h - 1.5) / 1.2));
    const cols = Math.max(1, Math.floor((w - 0.4) / 0.8));
    for (let r = 0; r < rows; r++) {
      for (let c = 0; c < cols; c++) {
        const lit = Math.random() > 0.35;
        const win = new THREE.Mesh(winGeo, lit ? winMatLit : winMatDark);
        const wx = x - (w / 2) + 0.5 + c * 0.8;
        const wy = 0.8 + r * 1.2;
        win.position.set(wx, wy, z + d / 2 + 0.01);
        parent.add(win);
      }
    }
  }

  // ── helper: add a simple mesh to buildingsGroup ──────────────────────────
  function addMesh(geo, color, x, y, z, opts) {
    const mat = new THREE.MeshStandardMaterial(Object.assign({ color, roughness: 0.8, metalness: 0.15 }, opts || {}));
    const m = new THREE.Mesh(geo, mat);
    m.position.set(x, y, z);
    m.castShadow = true;
    buildingsGroup.add(m);
    return m;
  }

  // ── background row helper ──────────────────────────────────────────────
  function addRow(count, zBase, hMin, hMax, spread, colors) {
    for (let i = 0; i < count; i++) {
      const w = 1.4 + Math.random() * 1.8;
      const h = hMin + Math.random() * (hMax - hMin);
      const d = 1.5 + Math.random() * 2;
      const x = -spread / 2 + (i / count) * spread + (Math.random() - 0.5) * 3;
      const z = zBase + (Math.random() - 0.5) * 3;
      const color = colors[Math.floor(Math.random() * colors.length)];
      buildingsGroup.add(createBuilding(x, z, w, h, d, color));
      addWindows(buildingsGroup, x, z, w, h, d);
    }
  }

  // ══════════════════════════════════════════════════════════════════════════
  // CITY_SKYLINES — one function per city key
  // ══════════════════════════════════════════════════════════════════════════
  // Seeded LCG so each city looks the same on every visit
  function makeRng(seed) {
    let s = seed;
    return function() { s = (s * 1664525 + 1013904223) & 0xffffffff; return (s >>> 0) / 0xffffffff; };
  }

  const CITY_SKYLINES = {

    // ── AMSTERDAM ────────────────────────────────────────────────────────
    'amsterdam': function () {
      const rng = makeRng(1);
      const brickCols = [0x8B3a10, 0x9a3a15, 0x7a3018, 0x6B3A2A, 0xa04020, 0x8a3a18];
      // Three rows of canal houses, large and close
      [[18,-10,5,11,70],[20,-17,4,12,68],[16,-23,4,10,60]].forEach(([c,z,mn,mx,sp]) => {
        for (let i = 0; i < c; i++) {
          const w = 2.2 + rng()*2.5, h = mn + rng()*(mx-mn), d = 2 + rng()*2.2;
          const x = -sp/2 + (i/c)*sp + (rng()-0.5)*2.5, zz = z + (rng()-0.5)*2;
          const col = brickCols[Math.floor(rng()*brickCols.length)];
          buildingsGroup.add(createBuilding(x, zz, w, h, d, col));
          addWindows(buildingsGroup, x, zz, w, h, d);
          if (rng()>0.35) buildingsGroup.add(createGabledRoof(x, h-0.5, zz, w, d, rng()>0.5?0x6a1a10:0x2a2a2a));
        }
      });
      addRow(12,-30,5,12,55,brickCols);
      // Westertoren — tall green spire, close and large
      addMesh(new THREE.BoxGeometry(3,26,3), 0x6a6070, -5,13,-15);
      addMesh(new THREE.BoxGeometry(4.5,2.5,4.5), 0x7a7080, -5,27,-15);
      addMesh(new THREE.CylinderGeometry(2,2,2.5,8), 0x7a7080, -5,29.5,-15);
      addMesh(new THREE.ConeGeometry(1.8,9,8), 0x44aa66, -5,33,-15);
      addMesh(new THREE.SphereGeometry(0.6,8,8), 0xddaa00, -5,38,-15, {metalness:0.7});
      addMesh(new THREE.CylinderGeometry(0.1,0.2,2,6), 0xaaaaaa, -5,39.2,-15);
      // Oude Kerk — dark stepped tower
      addMesh(new THREE.BoxGeometry(2.8,22,2.8), 0x4a4040, 10,11,-14);
      addMesh(new THREE.BoxGeometry(4,2,4), 0x554848, 10,23,-14);
      addMesh(new THREE.ConeGeometry(1.6,5,4), 0x8B7355, 10,26,-14);
      // Canal water strips
      addMesh(new THREE.BoxGeometry(80,0.15,5), 0x1a3055, 0,-0.42,-7);
      addMesh(new THREE.BoxGeometry(80,0.15,4), 0x1a3055, 0,-0.42,-14);

      // De Wallen — red-light district block along the canal
      const rlRng = makeRng(42);
      const rlX = [-22, -19, -16, -13, -10];
      rlX.forEach((bx, i) => {
        const bw = 1.8 + rlRng() * 0.8;
        const bh = 5 + rlRng() * 4;
        const bd = 1.8 + rlRng() * 0.6;
        const bz = -9 + (rlRng() - 0.5) * 0.8;
        // Dark brick building
        buildingsGroup.add(createBuilding(bx, bz, bw, bh, bd, 0x3a1a18));
        if (rlRng() > 0.3) buildingsGroup.add(createGabledRoof(bx, bh - 0.5, bz, bw, bd, 0x1a0a08));
        // Red glowing windows — the signature look
        const winGeo = new THREE.PlaneGeometry(0.55, 0.75);
        const floors = Math.max(1, Math.floor((bh - 1.2) / 1.4));
        for (let f = 0; f < floors; f++) {
          const redMat = new THREE.MeshStandardMaterial({
            color: 0xff1133,
            emissive: 0xff0022,
            emissiveIntensity: 1.2 + rlRng() * 0.6,
            roughness: 1,
            transparent: true,
            opacity: 0.88,
          });
          const win = new THREE.Mesh(winGeo, redMat);
          win.position.set(bx, 1.0 + f * 1.4, bz + bd / 2 + 0.01);
          buildingsGroup.add(win);
          // Faint pink curtain behind the window
          const curtainMat = new THREE.MeshStandardMaterial({
            color: 0xff88aa,
            emissive: 0xff3366,
            emissiveIntensity: 0.5,
            roughness: 1,
            transparent: true,
            opacity: 0.35,
          });
          const curtain = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.7), curtainMat);
          curtain.position.set(bx, 1.0 + f * 1.4, bz + bd / 2 - 0.05);
          buildingsGroup.add(curtain);
          // Silhouette in the window — dark figure shape (head + body)
          const silMat = new THREE.MeshStandardMaterial({ color: 0x110008, roughness: 1 });
          const silHead = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), silMat);
          silHead.position.set(bx + (rlRng() - 0.5) * 0.15, 1.28 + f * 1.4, bz + bd / 2 - 0.02);
          buildingsGroup.add(silHead);
          const silBody = new THREE.Mesh(new THREE.CylinderGeometry(0.09, 0.13, 0.42, 6), silMat);
          silBody.position.set(bx + (rlRng() - 0.5) * 0.15, 0.96 + f * 1.4, bz + bd / 2 - 0.02);
          buildingsGroup.add(silBody);
        }
        // Red lantern above door
        addMesh(new THREE.SphereGeometry(0.14, 8, 8), 0xff1133, bx, 1.1, bz + bd / 2 + 0.2,
          { emissive: 0xff0011, emissiveIntensity: 2.0 });
      });
    },

    // ── LONDON ───────────────────────────────────────────────────────────
    'london': function () {
      const lCols = [0x8a9090,0x778888,0x667777,0x889898,0x9a9a90,0x7a8888];
      addRow(16,-30,6,18,72,lCols);
      addRow(14,-22,5,14,65,lCols);
      // Thames
      addMesh(new THREE.BoxGeometry(80,0.2,12), 0x1a2535, 0,-0.42,-7);
      // Big Ben / Elizabeth Tower
      addMesh(new THREE.BoxGeometry(4,32,4), 0xd4c47a, 10,16,-15);
      addMesh(new THREE.BoxGeometry(6,2.5,6), 0xc8b86e, 10,33,-15);
      addMesh(new THREE.CylinderGeometry(2.5,3,3.5,8), 0xd4c47a, 10,36,-15);
      addMesh(new THREE.ConeGeometry(1.8,7,4), 0xd4c47a, 10,40,-15);
      addWindows(buildingsGroup, 10,-15,4,32,4);
      // St Paul's Cathedral
      addMesh(new THREE.BoxGeometry(16,7,12), 0xd0c8b0, -5,3.5,-18);
      addMesh(new THREE.CylinderGeometry(6,6,4.5,24), 0xd0c8b0, -5,9.5,-18);
      const spd = addMesh(new THREE.SphereGeometry(6.5,24,24), 0xddd8c8, -5,14,-18); spd.scale.y=0.68;
      addMesh(new THREE.CylinderGeometry(1,1.5,2.5,8), 0xd0c8b0, -5,20,-18);
      addMesh(new THREE.ConeGeometry(0.5,3.5,6), 0xddcc88, -5,22.5,-18);
      addWindows(buildingsGroup, -5,-18,16,7,12);
      // The Shard
      addMesh(new THREE.ConeGeometry(3,40,4), 0x88aacc, -20,20,-22, {metalness:0.55, roughness:0.15, transparent:true, opacity:0.92});
      // The Gherkin
      addMesh(new THREE.CylinderGeometry(0.3,3,28,16), 0x5577aa, 20,14,-24, {metalness:0.6, roughness:0.2});
      // Tower Bridge — prominent foreground
      addMesh(new THREE.BoxGeometry(3.5,20,3.5), 0x9a8a6a, -28,10,-10);
      addMesh(new THREE.BoxGeometry(3.5,20,3.5), 0x9a8a6a, -18,10,-10);
      addMesh(new THREE.BoxGeometry(3.5,3.5,3.5), 0x9a8a6a, -28,22,-10);
      addMesh(new THREE.BoxGeometry(3.5,3.5,3.5), 0x9a8a6a, -18,22,-10);
      addMesh(new THREE.BoxGeometry(12,1.5,3.5), 0x9a8a6a, -23,19,-10);
      addMesh(new THREE.BoxGeometry(12,1.5,4), 0x8a7a5a, -23,9,-10);
    },

    // ── PARIS ─────────────────────────────────────────────────────────────
    'paris': function () {
      const rng = makeRng(3);
      const pCols = [0xd4c8a8,0xccc0a0,0xd8cc99,0xcabf96,0xd0c4a4];
      [[20,-11,6,9,68],[18,-18,5,8,64],[14,-24,4,7,55]].forEach(([c,z,mn,mx,sp]) => {
        for (let i = 0; i < c; i++) {
          const w=2.5+rng()*2.5, h=mn+rng()*(mx-mn), d=2.5+rng()*2.5;
          const x=-sp/2+(i/c)*sp+(rng()-0.5)*2.5, zz=z+(rng()-0.5)*2;
          const col=pCols[Math.floor(rng()*pCols.length)];
          buildingsGroup.add(createBuilding(x,zz,w,h,d,col));
          addWindows(buildingsGroup, x,zz,w,h,d);
          if (rng()>0.35) buildingsGroup.add(createGabledRoof(x,h-0.5,zz,w,d,0x445544));
        }
      });
      addRow(10,-30,5,10,50,[0xaab0a0,0x9a9888,0x8a8878]);
      // Seine
      addMesh(new THREE.BoxGeometry(80,0.15,8), 0x1a2a3a, 0,-0.42,-7);
      // Eiffel Tower — hero, center, tall
      addMesh(new THREE.BoxGeometry(9,1,6), 0x8B8B6A, 0,0.5,-16);           // base pad
      addMesh(new THREE.CylinderGeometry(0.55,1.4,9,8), 0x8B8B6A, -4,4.5,-14);  // leg NW
      addMesh(new THREE.CylinderGeometry(0.55,1.4,9,8), 0x8B8B6A, 4,4.5,-14);   // leg NE
      addMesh(new THREE.CylinderGeometry(0.55,1.4,9,8), 0x8B8B6A, -4,4.5,-18);  // leg SW
      addMesh(new THREE.CylinderGeometry(0.55,1.4,9,8), 0x8B8B6A, 4,4.5,-18);   // leg SE
      addMesh(new THREE.BoxGeometry(10,1.8,6), 0x8B8B6A, 0,10,-16);          // 1st floor
      addMesh(new THREE.CylinderGeometry(1.4,2.5,8,8), 0x8B8B6A, 0,15,-16); // lower section
      addMesh(new THREE.BoxGeometry(6,1.5,4), 0x9a9a7a, 0,19.5,-16);         // 2nd floor
      addMesh(new THREE.CylinderGeometry(0.6,1.4,10,8), 0x9a9a7a, 0,25,-16);// upper section
      addMesh(new THREE.CylinderGeometry(0.15,0.55,12,8), 0x9a9a7a, 0,33,-16); // antenna shaft
      addMesh(new THREE.SphereGeometry(0.5,8,8), 0xddcc44, 0,39.5,-16, {emissive:0xddcc00, emissiveIntensity:0.3});
      // Sacré-Cœur on Montmartre hill
      addMesh(new THREE.BoxGeometry(18,5,5), 0x887766, 14,2.5,-22);
      addMesh(new THREE.BoxGeometry(7,4.5,9), 0xfafaf8, 14,6.5,-22);
      const scd = addMesh(new THREE.SphereGeometry(4.5,16,16), 0xfafaf8, 14,12,-22); scd.scale.y=1.25;
      addMesh(new THREE.CylinderGeometry(1.2,1.8,3.5,12), 0xfafaf8, 14,17,-22);
      addMesh(new THREE.ConeGeometry(1,3.5,8), 0xfafaf8, 14,21,-22);
      [10.5,17.5].forEach(sx => { const d=addMesh(new THREE.SphereGeometry(2.5,12,12), 0xfafaf8, sx,10,-22); d.scale.y=1.2; });
      // Notre-Dame
      addMesh(new THREE.BoxGeometry(9,5,14), 0xd4c8a8, -10,2.5,-17);
      addMesh(new THREE.BoxGeometry(3.5,18,3.5), 0xd4c8a8, -13,9,-14);
      addMesh(new THREE.BoxGeometry(3.5,18,3.5), 0xd4c8a8, -7,9,-14);
      addMesh(new THREE.ConeGeometry(0.7,9,4), 0x7a7060, -10,20,-15);
    },

    // ── BERLIN ───────────────────────────────────────────────────────────
    'berlin': function () {
      const bCols = [0x7a8090,0x6a6a78,0x888090,0x778080,0x6a7880,0x888888];
      addRow(18,-30,5,16,72,bCols);
      addRow(16,-20,4,10,62,bCols);
      // Spree river
      addMesh(new THREE.BoxGeometry(80,0.15,8), 0x1a2535, 0,-0.42,-7);
      // TV Tower (Fernsehturm) — massive needle center-stage
      addMesh(new THREE.CylinderGeometry(0.6,0.85,44,10), 0x999999, 0,22,-17, {metalness:0.3, roughness:0.6});
      addMesh(new THREE.SphereGeometry(4.5,20,20), 0xaaaaaa, 0,46,-17, {metalness:0.45, roughness:0.35});
      addMesh(new THREE.SphereGeometry(4.8,20,20), 0x88aacc, 0,46,-17, {transparent:true, opacity:0.25, metalness:0.7});
      addMesh(new THREE.CylinderGeometry(0.12,0.25,16,8), 0xcccccc, 0,55,-17);
      addWindows(buildingsGroup, 0,-17,1.5,44,1.5);
      // Brandenburg Gate — right up front
      [-7.5,-4.5,-1.5,1.5,4.5,7.5].forEach(cx =>
        addMesh(new THREE.CylinderGeometry(0.45,0.45,8,8), 0xd4c8a0, cx,4,-13));
      addMesh(new THREE.BoxGeometry(19,2.5,5), 0xd4c8a0, 0,9.5,-13);
      addMesh(new THREE.BoxGeometry(4.5,4,5), 0xccc0a0, 0,12,-13);
      addMesh(new THREE.BoxGeometry(2.5,1.2,2.5), 0xccaa44, 0,14.5,-13);
      // Reichstag
      addMesh(new THREE.BoxGeometry(16,7,10), 0xd0c8b0, -18,3.5,-17);
      addMesh(new THREE.BoxGeometry(16,1.2,10), 0xc8c0a8, -18,7.5,-17);
      addMesh(new THREE.CylinderGeometry(4,5.5,6,18), 0x88aabb, -18,11,-17, {metalness:0.65, roughness:0.15, transparent:true, opacity:0.78});
      addMesh(new THREE.SphereGeometry(0.6,8,8), 0xddcc88, -18,14.5,-17);
      addWindows(buildingsGroup, -18,-17,16,7,10);
    },

    // ── NEW YORK ──────────────────────────────────────────────────────────
    'new-york': function () {
      const nyCols = [0x445566,0x334455,0x667788,0x223344,0x556677,0x5a6a7a];
      addRow(28,-32,12,28,75,nyCols);
      addRow(22,-22,10,22,66,nyCols);
      addRow(18,-14,6,16,55,nyCols);
      // Hudson / East River
      addMesh(new THREE.BoxGeometry(80,0.2,14), 0x1a2535, 0,-0.42,-5);
      // Empire State Building
      addMesh(new THREE.BoxGeometry(8,14,8), 0x8a8a7a, 0,7,-18);
      addMesh(new THREE.BoxGeometry(6,10,6), 0x9a9a8a, 0,21,-18);
      addMesh(new THREE.BoxGeometry(4.5,8,4.5), 0x9a9a8a, 0,31,-18);
      addMesh(new THREE.BoxGeometry(3,5,3), 0xaaaa9a, 0,39,-18);
      addMesh(new THREE.CylinderGeometry(0.5,1.2,7,8), 0xbbbbaa, 0,45,-18);
      addMesh(new THREE.CylinderGeometry(0.1,0.35,14,8), 0xccccbb, 0,52,-18);
      addWindows(buildingsGroup, 0,-18,8,14,8);
      // Chrysler Building
      addMesh(new THREE.BoxGeometry(5.5,18,5.5), 0x8899aa, 12,9,-20);
      addMesh(new THREE.BoxGeometry(4,6,4), 0x8899aa, 12,27,-20);
      addMesh(new THREE.BoxGeometry(3,4,3), 0x99aacc, 12,33,-20);
      addMesh(new THREE.ConeGeometry(2.5,10,8), 0xaabbcc, 12,41,-20, {metalness:0.72, roughness:0.12});
      addMesh(new THREE.CylinderGeometry(0.1,0.35,6,6), 0xccddee, 12,47,-20);
      addWindows(buildingsGroup, 12,-20,5.5,18,5.5);
      // One World Trade Center
      addMesh(new THREE.CylinderGeometry(0.8,5.5,54,4), 0x6688aa, -12,27,-24, {metalness:0.55, roughness:0.18});
      addMesh(new THREE.CylinderGeometry(0.06,0.35,16,6), 0x99aabb, -12,60,-24);
      addWindows(buildingsGroup, -12,-24,5,54,5);
      // Brooklyn Bridge
      addMesh(new THREE.BoxGeometry(3.5,22,3.5), 0x9a9070, -28,11,-10);
      addMesh(new THREE.BoxGeometry(3.5,22,3.5), 0x9a9070, -18,11,-10);
      addMesh(new THREE.BoxGeometry(3.5,3.5,3.5), 0x9a9070, -28,23.5,-10);
      addMesh(new THREE.BoxGeometry(3.5,3.5,3.5), 0x9a9070, -18,23.5,-10);
      addMesh(new THREE.BoxGeometry(12,1.8,3.5), 0x8a8060, -23,21,-10);
      addMesh(new THREE.BoxGeometry(12,1.5,4.5), 0x8a8060, -23,10,-10);
    },

    // ── LOS ANGELES ───────────────────────────────────────────────────────
    'los-angeles': function () {
      const laCols = [0xcc8855,0xd4a870,0xddbb88,0xcca060,0xc49050,0xbb9955];
      addRow(30,-20,2,5,85,laCols);
      addRow(12,-30,4,14,55,[0x7a8890,0x889090,0x6a7880]);
      // Hollywood Hills — big green backdrop
      addMesh(new THREE.BoxGeometry(80,14,22), 0x4a5a38, 0,7,-46);
      addMesh(new THREE.BoxGeometry(72,6,14), 0x556644, 0,15,-48);
      // Hollywood Sign
      [-14,-11,-8,-5,-2,1,4,7,10].forEach(lx =>
        addMesh(new THREE.BoxGeometry(2.2,4.5,0.7), 0xffffff, lx,17,-46, {emissive:0xffffff, emissiveIntensity:0.06}));
      // Capitol Records — stacked disc building
      for (let r=0; r<6; r++) addMesh(new THREE.CylinderGeometry(3.8-r*0.2,3.8-r*0.2,2.2,20), 0xddccaa, 16,1+r*2.8,-17);
      addMesh(new THREE.CylinderGeometry(0.15,0.28,7,8), 0xdd1111, 16,18,-17, {emissive:0xcc0000, emissiveIntensity:0.6});
      // Griffith Observatory
      addMesh(new THREE.BoxGeometry(22,6,6), 0x887755, -16,3,-26);
      addMesh(new THREE.BoxGeometry(11,4.5,6), 0xd8d0c0, -16,7,-26);
      const gd = addMesh(new THREE.SphereGeometry(3.5,16,16), 0xd8d0c0, -16,11,-26); gd.scale.y=0.7;
      addMesh(new THREE.SphereGeometry(2,12,12), 0xd8d0c0, -21,10,-26).scale.y=0.7;
      addMesh(new THREE.SphereGeometry(2,12,12), 0xd8d0c0, -11,10,-26).scale.y=0.7;
      // Freeways
      addMesh(new THREE.BoxGeometry(80,0.35,2.5), 0x555555, 0,0.15,-9);
      addMesh(new THREE.BoxGeometry(80,0.35,2.5), 0x555555, 0,0.15,-12);
      // Palm trees
      [-26,-18,-10,0,10,18,26,-34,34].forEach((px,i) => {
        const tz=-8-(i%3)*3;
        addMesh(new THREE.CylinderGeometry(0.2,0.3,7+i%3,6), 0x8a6644, px,4,tz);
        const c=addMesh(new THREE.SphereGeometry(2,8,8), 0x2a6622, px,8.2,tz);
        c.scale.set(1.5,0.5,1.5);
      });
    },

    // ── TORONTO ──────────────────────────────────────────────────────────
    'toronto': function () {
      const tCols = [0x4477aa,0x5588bb,0x334455,0x446688,0x5577aa,0x667799];
      addRow(20,-30,8,22,65,tCols);
      addRow(12,-20,5,14,50,[0x8899aa,0x7788aa,0x6677aa]);
      // Lake Ontario
      addMesh(new THREE.BoxGeometry(80,0.2,18), 0x0d2030, 0,-0.42,-4);
      addRow(8,-12,2,4,40,[0x445566,0x556677]);
      // CN Tower — unmistakable tall needle
      addMesh(new THREE.CylinderGeometry(1.4,2,3.5,6), 0xcccccc, 0,1.75,-17);  // base legs
      addMesh(new THREE.CylinderGeometry(0.55,1,16,8), 0xbbbbbb, 0,12,-17);
      addMesh(new THREE.CylinderGeometry(0.32,0.55,30,8), 0xaaaaaa, 0,35,-17, {metalness:0.35, roughness:0.55});
      addMesh(new THREE.CylinderGeometry(5.5,6.5,3,24), 0x999999, 0,50.5,-17);  // pod ring
      addMesh(new THREE.CylinderGeometry(4,4,5.5,24), 0x888888, 0,53.5,-17);    // main pod
      addMesh(new THREE.CylinderGeometry(2.8,2.8,3.5,20), 0x888888, 0,57.5,-17);
      addMesh(new THREE.CylinderGeometry(0.1,0.32,18,8), 0xbbbbbb, 0,66,-17);   // antenna
      addWindows(buildingsGroup, 0,-17,1,30,1);
      // Rogers Centre dome stadium
      addMesh(new THREE.BoxGeometry(22,3.5,22), 0x556677, -14,1.75,-18);
      addMesh(new THREE.CylinderGeometry(9,10,6,24), 0x7799bb, -14,7,-18, {metalness:0.45, roughness:0.4});
      addMesh(new THREE.SphereGeometry(9,24,24), 0x6688aa, -14,9,-18, {transparent:true, opacity:0.45, metalness:0.65}).scale.y=0.38;
    },

    // ── MEXICO CITY ───────────────────────────────────────────────────────
    'mexico-city': function () {
      const mxCols = [0xcc8855,0xddaa66,0xdd9988,0xcc9977,0xbb8855,0xd49060];
      addRow(24,-22,3,8,70,mxCols);
      addRow(12,-30,6,14,50,[0x8899aa,0x778899,0x6677aa]);
      // Metropolitan Cathedral — broad stone façade
      addMesh(new THREE.BoxGeometry(20,8,13), 0xd4c8a0, 0,4,-16);
      addMesh(new THREE.BoxGeometry(18,2,13), 0xccc0a0, 0,9,-16);
      addMesh(new THREE.BoxGeometry(3.5,22,3.5), 0xd4c8a0, -6,11,-14);
      addMesh(new THREE.BoxGeometry(3.5,22,3.5), 0xd4c8a0, 6,11,-14);
      addMesh(new THREE.ConeGeometry(1.4,5.5,4), 0xd0c0a0, -6,23,-14);
      addMesh(new THREE.ConeGeometry(1.4,5.5,4), 0xd0c0a0, 6,23,-14);
      const cd = addMesh(new THREE.SphereGeometry(4,16,16), 0xd0c8b0, 0,12,-16); cd.scale.y=0.65;
      addWindows(buildingsGroup, 0,-16,20,8,13);
      // Aztec Pyramid (Templo Mayor) — large stepped hero
      for (let l=0; l<7; l++) {
        addMesh(new THREE.BoxGeometry(16-l*2.1,3,16-l*2.1), 0xa09070, -14,1.5+l*3,-16);
      }
      addMesh(new THREE.BoxGeometry(4,4,4), 0xbb7744, -14,22.5,-16);
      // Angel of Independence
      addMesh(new THREE.BoxGeometry(3,4,3), 0xd4c0a0, 12,2,-13);
      addMesh(new THREE.CylinderGeometry(0.9,1.2,20,12), 0xd4c0a0, 12,12,-13);
      addMesh(new THREE.SphereGeometry(1.8,12,12), 0xddaa44, 12,23,-13, {metalness:0.65});
      // Latin American Tower
      addMesh(new THREE.BoxGeometry(5,20,5), 0x8899aa, -4,10,-22);
      addMesh(new THREE.BoxGeometry(4,8,4), 0x8899aa, -4,24,-22);
      addMesh(new THREE.BoxGeometry(3,6,3), 0x99aacc, -4,31,-22);
      addMesh(new THREE.CylinderGeometry(0.12,0.35,9,6), 0xaabbcc, -4,38,-22);
      addWindows(buildingsGroup, -4,-22,5,20,5);

      // Gangs & Cartels — street firefight on Insurgentes
      const mxRng2 = makeRng(77);
      const gangCols = [0x1a1a22, 0x2a1a10, 0x22331a, 0x22151a];

      function mkGangster(x, z, crouched, facingRight) {
        const col = gangCols[Math.floor(mxRng2() * gangCols.length)];
        const bh = crouched ? 0.38 : 0.58;
        const body = new THREE.Mesh(
          new THREE.CylinderGeometry(0.11, 0.14, bh, 6),
          new THREE.MeshStandardMaterial({ color: col, roughness: 0.9 })
        );
        body.position.set(x, bh / 2, z);
        buildingsGroup.add(body);
        const head = new THREE.Mesh(
          new THREE.SphereGeometry(0.12, 6, 6),
          new THREE.MeshStandardMaterial({ color: 0xc49a6c, roughness: 0.8 })
        );
        head.position.set(x, crouched ? 0.5 : 0.70, z);
        buildingsGroup.add(head);
        // Gun barrel
        const gunDir = facingRight ? 1 : -1;
        const gun = new THREE.Mesh(
          new THREE.BoxGeometry(0.38, 0.06, 0.06),
          new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 0.5, metalness: 0.7 })
        );
        gun.position.set(x + gunDir * 0.28, crouched ? 0.42 : 0.60, z + 0.08);
        buildingsGroup.add(gun);
        // Muzzle flash sphere
        const flashMat = new THREE.MeshStandardMaterial({
          color: 0xffaa00, emissive: 0xffdd00, emissiveIntensity: 0, roughness: 1,
        });
        mxFlashMats.push({ mat: flashMat, timer: mxRng2() * 2.5 });
        const flash = new THREE.Mesh(new THREE.SphereGeometry(0.13, 6, 6), flashMat);
        flash.position.set(x + gunDir * 0.56, crouched ? 0.42 : 0.60, z + 0.08);
        buildingsGroup.add(flash);
      }

      // Cover props — left side (gang)
      addMesh(new THREE.BoxGeometry(2.2, 0.70, 0.95), 0x334422, -18, 0.35, -11); // dumpster
      addMesh(new THREE.BoxGeometry(1.8, 0.55, 0.90), 0x667744, -21, 0.28, -10); // crate
      // Cover props — right side (cartel)
      addMesh(new THREE.BoxGeometry(2.5, 0.62, 1.00), 0x443322, 18, 0.31, -11);  // overturned car
      addMesh(new THREE.BoxGeometry(1.2, 0.45, 0.80), 0x222222, 21, 0.23, -10);  // debris

      // Gang members — left side, facing right
      [[-20,-11,true],[-18.2,-10.4,false],[-15.8,-11.3,true]]
        .forEach(([x,z,cr]) => mkGangster(x, z, cr, true));
      // Cartel members — right side, facing left
      [[20,-11,true],[18.4,-10.5,false],[15.6,-11.4,true]]
        .forEach(([x,z,cr]) => mkGangster(x, z, cr, false));

      // Blood/chalk patches on the street
      [-17.5,-14.5,14.5,19.5].forEach(sx => {
        addMesh(
          new THREE.CylinderGeometry(0.25 + mxRng2() * 0.2, 0.3 + mxRng2() * 0.15, 0.02, 8),
          0x550000, sx, 0.01, -10.8
        );
      });
    },

    // ── TOKYO ─────────────────────────────────────────────────────────────
    'tokyo': function () {
      const tCols = [0x334455,0x445566,0x223344,0x556677,0x4a5a6a,0x667788];
      addRow(32,-32,10,26,76,tCols);
      addRow(24,-22,6,16,66,tCols);
      // Low traditional shitamachi foreground
      const rng = makeRng(9);
      for (let i=0; i<16; i++) {
        const w=2.5+rng()*2, h=3+rng()*2, d=2.5+rng()*2;
        const x=-30+i*4+(rng()-0.5)*2, z=-10+(rng()-0.5)*2;
        buildingsGroup.add(createBuilding(x,z,w,h,d,0x777070));
        buildingsGroup.add(createGabledRoof(x,h-0.5,z,w,d,0x333330));
      }
      // Tokyo Tower — orange lattice, larger and close
      addMesh(new THREE.BoxGeometry(2.2,36,2.2), 0xee4422, -10,18,-17);
      [3,7,11,15,19,23,27,31].forEach(y => {
        addMesh(new THREE.BoxGeometry(6,0.45,0.45), 0xffffff, -10,y,-17);
        addMesh(new THREE.BoxGeometry(6,0.35,0.35), 0xee4422, -10,y+1.8,-17);
      });
      addMesh(new THREE.CylinderGeometry(0.6,1.4,5,4), 0xee4422, -10,38.5,-17);
      addMesh(new THREE.CylinderGeometry(0.18,0.5,9,6), 0xffffff, -10,44,-17);
      addWindows(buildingsGroup, -10,-17,2.2,36,2.2);
      // Tokyo Skytree — tapering triangular tower
      addMesh(new THREE.CylinderGeometry(0.5,3.5,54,6), 0x8899bb, 12,27,-24, {metalness:0.45, roughness:0.35});
      addMesh(new THREE.CylinderGeometry(5.5,5.5,3.5,24), 0x99aacc, 12,52,-24, {metalness:0.5});
      addMesh(new THREE.CylinderGeometry(4.5,4.5,4.5,24), 0x99aacc, 12,56,-24);
      addMesh(new THREE.ConeGeometry(0.5,8,6), 0xaabbdd, 12,61,-24);
      addWindows(buildingsGroup, 12,-24,3,54,3);
      // Neon-lit high-rises
      [[-22,-18],[18,-20],[-5,-15],[24,-22]].forEach(([bx,bz]) => {
        const h=14+Math.floor(bx/5)%4*3;
        addMesh(new THREE.BoxGeometry(4,h,4), 0x223344, bx,h/2,bz, {emissive:0x001133, emissiveIntensity:0.5});
        addWindows(buildingsGroup, bx,bz,4,h,4);
      });
    },

    // ── BEIJING ───────────────────────────────────────────────────────────
    'beijing': function () {
      const bjCols = [0x778899,0x667788,0x8899aa,0x556677,0x7788aa];
      addRow(20,-32,10,26,70,bjCols);
      // Tiananmen Gate — wide red fortification up front
      addMesh(new THREE.BoxGeometry(30,8,8), 0xcc3322, 0,4,-14);
      addMesh(new THREE.BoxGeometry(28,2.5,8), 0xddbb33, 0,9.5,-14);
      addMesh(new THREE.BoxGeometry(26,2,8.5), 0xddbb33, 0,12,-14);
      [-10,-5,0,5,10].forEach(gx => addMesh(new THREE.BoxGeometry(3,7,8.5), 0x220800, gx,3.5,-14));
      addMesh(new THREE.BoxGeometry(7,9,8), 0xcc3322, -13.5,4.5,-14);
      addMesh(new THREE.BoxGeometry(7,9,8), 0xcc3322, 13.5,4.5,-14);
      // CCTV Tower — bent loop
      const ct1 = addMesh(new THREE.BoxGeometry(4.5,28,4.5), 0x445566, -7,14,-22); ct1.rotation.z=0.19;
      const ct2 = addMesh(new THREE.BoxGeometry(4.5,28,4.5), 0x445566, 7,14,-22);  ct2.rotation.z=-0.19;
      addMesh(new THREE.BoxGeometry(18,5,4.5), 0x445566, 0,29,-22);
      addMesh(new THREE.BoxGeometry(18,5,4.5), 0x334455, 0,4,-22);
      addWindows(buildingsGroup, -7,-22,4.5,28,4.5);
      addWindows(buildingsGroup, 7,-22,4.5,28,4.5);
      // Temple of Heaven — tripled cylindrical tiers with blue cones
      addMesh(new THREE.CylinderGeometry(8,8,2.5,24), 0xcc3322, 18,1.25,-18);
      addMesh(new THREE.CylinderGeometry(6,6,2.5,24), 0xcc3322, 18,3.75,-18);
      addMesh(new THREE.CylinderGeometry(4,4,2.5,24), 0xcc3322, 18,6.25,-18);
      addMesh(new THREE.ConeGeometry(5,6,24), 0x1133aa, 18,11,-18);
      addMesh(new THREE.ConeGeometry(3.5,4,24), 0x1133aa, 18,16,-18);
      addMesh(new THREE.ConeGeometry(1.5,2.5,16), 0x1133aa, 18,19,-18);
      addMesh(new THREE.SphereGeometry(0.7,8,8), 0xddaa44, 18,21,-18, {metalness:0.75});
    },

    // ── SEOUL ─────────────────────────────────────────────────────────────
    'seoul': function () {
      const sCols = [0x4488bb,0x3377aa,0x556677,0x6688aa,0x5577bb,0x4466aa];
      addRow(24,-30,12,28,70,sCols);
      addRow(12,-18,3,5,50,[0x9999aa,0x8a8a90,0xaaaaaa]);
      // Han River
      addMesh(new THREE.BoxGeometry(80,0.25,14), 0x1a2a4a, 0,-0.42,-5);
      addMesh(new THREE.BoxGeometry(80,0.8,4.5), 0x555555, 0,0.4,-8);   // bridge
      // Lotte World Tower — sleek tapering needle, hero
      addMesh(new THREE.BoxGeometry(7,12,7), 0x88aacc, -8,6,-18);
      addMesh(new THREE.BoxGeometry(6,11,6), 0x88aacc, -8,17.5,-18);
      addMesh(new THREE.BoxGeometry(5,10,5), 0x88aacc, -8,28,-18);
      addMesh(new THREE.BoxGeometry(4,10,4), 0x99aadd, -8,38,-18);
      addMesh(new THREE.BoxGeometry(2.8,8,2.8), 0xaabbee, -8,47,-18);
      addMesh(new THREE.ConeGeometry(1.5,16,8), 0xbbccff, -8,57,-18);
      addWindows(buildingsGroup, -8,-18,7,12,7);
      addWindows(buildingsGroup, -8,-18,6,11,6);
      // N Seoul Tower on its green hill
      addMesh(new THREE.BoxGeometry(22,10,12), 0x3a5530, 8,5,-20);
      addMesh(new THREE.BoxGeometry(7,6,7), 0x777777, 8,12,-20);
      addMesh(new THREE.CylinderGeometry(0.5,0.7,26,8), 0x888888, 8,28,-20);
      addMesh(new THREE.CylinderGeometry(4,4,5.5,20), 0x999999, 8,43,-20);
      addMesh(new THREE.SphereGeometry(0.8,8,8), 0xee1111, 8,47,-20, {emissive:0xcc0000, emissiveIntensity:1.2});
      addWindows(buildingsGroup, 8,-20,1,26,1);
    },

    // ── BANGKOK ───────────────────────────────────────────────────────────
    'bangkok': function () {
      const bkCols = [0x889966,0x998855,0x8899aa,0x99aa88,0x778866];
      addRow(20,-26,5,20,68,bkCols);
      // Chao Phraya river
      addMesh(new THREE.BoxGeometry(80,0.2,12), 0x1a3025, 0,-0.42,-6);
      // Wat Arun — tall ornate prang, the hero
      addMesh(new THREE.CylinderGeometry(6.5,8.5,5,24), 0xf5f0e8, 0,2.5,-16);
      addMesh(new THREE.CylinderGeometry(5,6.5,4.5,24), 0xf5f0e8, 0,7,-16);
      addMesh(new THREE.CylinderGeometry(3.8,5,4,24), 0xf5f0e8, 0,11,-16);
      addMesh(new THREE.CylinderGeometry(2.8,3.8,3.5,24), 0xf5f0e8, 0,14.5,-16);
      addMesh(new THREE.CylinderGeometry(1.8,2.8,3,24), 0xf5f0e8, 0,17.5,-16);
      addMesh(new THREE.CylinderGeometry(1,1.8,2.5,20), 0xf5f0e8, 0,20,-16);
      addMesh(new THREE.ConeGeometry(0.8,7,16), 0xddcc88, 0,23,-16);
      addMesh(new THREE.SphereGeometry(0.5,8,8), 0xddaa44, 0,27,-16, {metalness:0.7});
      // 4 flanking prangs
      [[-7,-14],[7,-14],[-5,-18],[5,-18]].forEach(([px,pz]) => {
        addMesh(new THREE.CylinderGeometry(1.5,2.2,9,12), 0xf5f0e8, px,4.5,pz);
        addMesh(new THREE.CylinderGeometry(1,1.5,5,12), 0xf5f0e8, px,11.5,pz);
        addMesh(new THREE.ConeGeometry(0.7,5,12), 0xddcc88, px,15.5,pz);
      });
      // Wat Pho coloured roof tiers
      addMesh(new THREE.BoxGeometry(20,5,7), 0xf0e8d0, 14,2.5,-17);
      addMesh(new THREE.BoxGeometry(18,2.5,6.5), 0xdd5533, 14,6.5,-17);
      addMesh(new THREE.BoxGeometry(16,2,6), 0x339933, 14,9,-17);
      addMesh(new THREE.BoxGeometry(14,2,5.5), 0xddaa33, 14,11,-17);
      // Golden chedi
      addMesh(new THREE.CylinderGeometry(3.5,4.5,4,16), 0xddaa44, -13,2,-18, {metalness:0.5});
      addMesh(new THREE.CylinderGeometry(2.5,3.5,3.5,16), 0xddaa44, -13,5.5,-18, {metalness:0.5});
      addMesh(new THREE.CylinderGeometry(1.5,2.5,3,16), 0xddaa44, -13,8.5,-18, {metalness:0.5});
      addMesh(new THREE.ConeGeometry(1,6,16), 0xeecc55, -13,12,-18, {metalness:0.6});
      // Tropical trees
      [-24,-16,-8,0,8,18,26,-30].forEach((tx,i) => {
        const tz=-9-(i%3)*2;
        addMesh(new THREE.CylinderGeometry(0.2,0.3,6+i%3,6), 0x8a6644, tx,3.5,tz);
        const c=addMesh(new THREE.SphereGeometry(2.2,8,8), 0x2a6622, tx,8,tz);
        c.scale.set(1.5,0.5,1.5);
      });
    },

    // ── DUBAI ─────────────────────────────────────────────────────────────
    'dubai': function () {
      const dTower = [0x88aabb,0x6699aa,0x5588aa,0x7799bb,0x4488aa];
      addRow(22,-32,14,28,70,dTower);
      addRow(14,-22,8,18,58,dTower);
      addRow(14,-14,2,5,70,[0xd4a96a,0xc8a060,0xd4b070]);
      // Persian Gulf
      addMesh(new THREE.BoxGeometry(80,0.2,18), 0x0d2535, 0,-0.42,-4);
      // Burj Khalifa — absolutely dominant
      addMesh(new THREE.CylinderGeometry(0.15,2.5,56,6), 0x88aabb, 0,28,-22, {metalness:0.56, roughness:0.14});
      addMesh(new THREE.CylinderGeometry(2.5,2.5,1.8,16), 0x99bbcc, 0,47,-22, {metalness:0.6});
      addMesh(new THREE.CylinderGeometry(0.12,0.35,20,6), 0xbbccdd, 0,66,-22, {metalness:0.6});
      // 3 Y-shaped buttresses
      for (let b=0; b<3; b++) {
        const ba=b*(Math.PI*2/3);
        addMesh(new THREE.BoxGeometry(2,18,2), 0x99bbcc, Math.cos(ba)*2.8,9,-22+Math.sin(ba)*2.8, {metalness:0.4});
      }
      addWindows(buildingsGroup, 0,-22,3,56,3);
      // Burj Al Arab — iconic sail
      addMesh(new THREE.BoxGeometry(0.8,30,9), 0xffffff, -14,15,-18, {metalness:0.45, roughness:0.25});
      addMesh(new THREE.BoxGeometry(6,2.5,9), 0xffeedd, -14,1.25,-18);
      addMesh(new THREE.BoxGeometry(0.6,15,0.6), 0xddddcc, -17,9.5,-18); // support arm
      // Dubai Frame — gold rectangle foreground
      addMesh(new THREE.BoxGeometry(1.8,22,1.8), 0xddaa44, 18,11,-14, {metalness:0.72, roughness:0.18});
      addMesh(new THREE.BoxGeometry(1.8,22,1.8), 0xddaa44, 23,11,-14, {metalness:0.72, roughness:0.18});
      addMesh(new THREE.BoxGeometry(7,2.5,1.8), 0xddaa44, 20.5,23,-14, {metalness:0.72, roughness:0.18});
      addMesh(new THREE.BoxGeometry(7,2.5,1.8), 0xddaa44, 20.5,1,-14, {metalness:0.72, roughness:0.18});
      // Emirates Towers
      const et1=addMesh(new THREE.CylinderGeometry(0.5,3.5,32,4), 0x667788, 8,16,-26, {metalness:0.55}); et1.rotation.y=Math.PI/4;
      const et2=addMesh(new THREE.CylinderGeometry(0.3,2.5,26,4), 0x556677, 5,13,-26, {metalness:0.55}); et2.rotation.y=Math.PI/4;
      addWindows(buildingsGroup, 8,-26,3,32,3);
    },

    // ── SINGAPORE ─────────────────────────────────────────────────────────
    'singapore': function () {
      const sgCols = [0x4a8a7a,0x336655,0x5599aa,0x4a7a6a,0x558877];
      addRow(20,-28,8,20,65,sgCols);
      // Marina Bay
      addMesh(new THREE.BoxGeometry(80,0.2,14), 0x0d2530, 0,-0.42,-5);
      // Marina Bay Sands — three towers + skypark, large and close
      [-7,0,7].forEach(tx => {
        addMesh(new THREE.BoxGeometry(5,32,5), 0x8899aa, tx,16,-20, {metalness:0.42, roughness:0.38});
        addWindows(buildingsGroup, tx,-20,5,32,5);
      });
      addMesh(new THREE.BoxGeometry(24,3,8), 0x99aa88, 0,33,-20);
      addMesh(new THREE.BoxGeometry(9,2.5,8), 0x88aa77, -14.5,33,-20);
      addMesh(new THREE.BoxGeometry(9,2.5,8), 0x88aa77, 14.5,33,-20);
      addMesh(new THREE.BoxGeometry(5,4,14), 0x6a9a66, 0,36,-20);
      // Supertrees — tall canopy structures
      [-16,-12,-8,-4,4,8,12].forEach((sx,i) => {
        const h=12+(i%3)*2.5;
        addMesh(new THREE.CylinderGeometry(0.28,0.55,h,8), 0x334422, sx,h/2,-13);
        addMesh(new THREE.CylinderGeometry(5,6,3,16), 0x336633, sx,h+1.5,-13);
        addMesh(new THREE.CylinderGeometry(0.12,0.12,0.6,6), 0xffaa00, sx,h+3.2,-13, {emissive:0xffaa00, emissiveIntensity:0.9});
      });
      // Singapore Flyer
      addMesh(new THREE.TorusGeometry(9,0.45,8,56), 0x88aacc, 22,10,-18, {metalness:0.55});
      addMesh(new THREE.CylinderGeometry(0.6,0.6,18,8), 0x999aaa, 22,9,-18);
    },

    // ── MUMBAI ─────────────────────────────────────────────────────────────
    'mumbai': function () {
      const muCols = [0xd4c8a0,0xccbb99,0xd8cc99,0xbbaa88,0xccbb88];
      addRow(26,-22,3,8,72,muCols);
      addRow(10,-30,12,24,35,[0x4477aa,0x5588bb,0x446688]);
      // Arabian Sea
      addMesh(new THREE.BoxGeometry(80,0.2,18), 0x0d2535, 0,-0.42,-5);
      // Gateway of India — prominent arch monument
      addMesh(new THREE.BoxGeometry(16,8,7), 0xd4c8a0, 0,4,-14);
      addMesh(new THREE.BoxGeometry(3.5,16,3.5), 0xd4c8a0, -5.5,8,-14);
      addMesh(new THREE.BoxGeometry(3.5,16,3.5), 0xd4c8a0, 5.5,8,-14);
      addMesh(new THREE.TorusGeometry(4.5,0.65,8,32,Math.PI), 0xd4c8a0, 0,14,-14);
      const gid = addMesh(new THREE.SphereGeometry(3.5,16,16), 0xddd0a8, 0,19,-14); gid.scale.y=0.7;
      addMesh(new THREE.CylinderGeometry(0.25,0.35,2.5,8), 0xccaa55, 0,22.5,-14);
      addMesh(new THREE.ConeGeometry(1.2,2.5,8), 0xd4c8a0, -5.5,17,-14);
      addMesh(new THREE.ConeGeometry(1.2,2.5,8), 0xd4c8a0, 5.5,17,-14);
      addWindows(buildingsGroup, 0,-14,16,8,7);
      // Bandra-Worli Sea Link — cable-stayed bridge
      addMesh(new THREE.BoxGeometry(3,22,3), 0x888888, -24,11,-10);
      addMesh(new THREE.BoxGeometry(3,22,3), 0x888888, -14,11,-10);
      addMesh(new THREE.BoxGeometry(12,1.8,4), 0x777777, -19,20,-10);
      addMesh(new THREE.BoxGeometry(12,1,3.5), 0x777777, -19,10,-10);
      [-22,-20,-18,-16,-14].forEach(cx => addMesh(new THREE.BoxGeometry(0.25,12,0.25), 0x999999, cx,15,-10));
    },

    // ── CAIRO ─────────────────────────────────────────────────────────────
    'cairo': function () {
      const cairoCols = [0xc8a96a,0xd4b070,0xbb9955,0xcc9944,0xd4aa60];
      addRow(22,-20,3,7,72,cairoCols);
      // Nile
      addMesh(new THREE.BoxGeometry(18,0.2,80), 0x1a4455, -30,0,0);
      // Great Pyramid — HUGE and close, the icon
      for (let l=0; l<14; l++) {
        const s=30-l*2.1;
        addMesh(new THREE.BoxGeometry(s,3,s), 0xd4b483, -12,1.5+l*3,-18);
      }
      // Khafre pyramid (slightly behind, slightly smaller)
      for (let l=0; l<11; l++) {
        const s=22-l*1.9;
        addMesh(new THREE.BoxGeometry(s,2.5,s), 0xd4b078, -2,1.25+l*2.5,-22);
      }
      // Menkaure pyramid (small, front right)
      for (let l=0; l<8; l++) {
        const s=13-l*1.5;
        addMesh(new THREE.BoxGeometry(s,2,s), 0xd4b070, 8,1+l*2,-15);
      }
      // Sphinx — crouching in front of pyramids
      addMesh(new THREE.BoxGeometry(12,3.5,4.5), 0xd4aa70, -2,1.75,-12);
      addMesh(new THREE.SphereGeometry(2.2,14,14), 0xd4aa70, 3,5.5,-12);
      addMesh(new THREE.BoxGeometry(2.5,1.8,1.2), 0xd4aa70, 3,4,-11);
      // Cairo Tower
      addMesh(new THREE.CylinderGeometry(0.55,0.7,28,10), 0xaa8855, 16,14,-15);
      [5,9,13,17,21,25].forEach(ty => addMesh(new THREE.TorusGeometry(2,0.28,6,24), 0xaa8855, 16,ty,-15));
      addMesh(new THREE.CylinderGeometry(3,3.5,3.5,20), 0x99aa55, 16,30,-15);
      // Minarets
      [[-16,-18],[20,-18],[-8,-20],[12,-22],[-26,-14]].forEach(([mx,mz],i) => {
        const mh=13+(i%3)*3;
        addMesh(new THREE.CylinderGeometry(0.4,0.5,mh,8), 0xd4c8a0, mx,mh/2,mz);
        addMesh(new THREE.CylinderGeometry(0.65,0.65,0.65,12), 0xc8b890, mx,mh,mz);
        addMesh(new THREE.ConeGeometry(0.45,2.8,8), 0x88aa55, mx,mh+1.5,mz);
      });
    },

    // ── SYDNEY ────────────────────────────────────────────────────────────
    'sydney': function () {
      const syCols = [0x4477aa,0x335566,0x5588aa,0x4466bb,0x557799];
      addRow(16,-30,10,24,65,syCols);
      // Harbour — the scene is on the water
      addMesh(new THREE.BoxGeometry(80,0.2,22), 0x0d2030, 0,-0.42,2);
      // Opera House — white sail shells, close and large
      addMesh(new THREE.BoxGeometry(22,1.8,16), 0xe8e8e2, -8,0.9,5);
      addMesh(new THREE.BoxGeometry(22,1.2,16), 0xf0f0ea, -8,2.1,5);
      // Concert hall — 3 large shells
      [{x:-13,h:12,z:5,ry:0,rx:0.1},{x:-8,h:14,z:6,ry:0.08,rx:0.05},{x:-3,h:11,z:5,ry:-0.12,rx:0.1}].forEach(({x,h,z,ry,rx}) => {
        const s=addMesh(new THREE.CylinderGeometry(0,h*0.48,h,4,1,true), 0xf8f8f4, x,2.1,z);
        s.rotation.x=Math.PI/2+rx; s.rotation.y=ry; s.scale.z=0.38;
      });
      // Opera theatre — 2 smaller shells
      [{x:-13,h:9,z:1},{x:-10,h:10,z:1}].forEach(({x,h,z}) => {
        const s=addMesh(new THREE.CylinderGeometry(0,h*0.46,h,4,1,true), 0xf8f8f4, x,2.1,z);
        s.rotation.x=Math.PI/2+0.1; s.scale.z=0.36;
      });
      // Harbour Bridge — iconic grey steel arch
      addMesh(new THREE.BoxGeometry(2.5,20,2.5), 0x888888, -30,10,-1);
      addMesh(new THREE.BoxGeometry(2.5,20,2.5), 0x888888, -16,10,-1);
      addMesh(new THREE.BoxGeometry(16,1.8,5), 0x777777, -23,18,-1);
      addMesh(new THREE.CylinderGeometry(9,9,1.8,24,1,true), 0x888888, -23,11,-1);
      addMesh(new THREE.BoxGeometry(2.5,2.5,2.5), 0x888888, -30,22,-1);
      addMesh(new THREE.BoxGeometry(2.5,2.5,2.5), 0x888888, -16,22,-1);
      addWindows(buildingsGroup, -8,5,22,1.8,16);
    },

    // ── CAPE TOWN ─────────────────────────────────────────────────────────
    'cape-town': function () {
      const rng = makeRng(17);
      // Table Mountain — the defining backdrop, massive flat top
      addMesh(new THREE.BoxGeometry(72,12,20), 0x7a6855, 0,6,-36);
      addMesh(new THREE.BoxGeometry(62,3,20), 0x8a7865, 0,12.5,-36);
      addMesh(new THREE.ConeGeometry(12,24,4), 0x6a5845, 30,12,-34);   // Devil's Peak
      addMesh(new THREE.ConeGeometry(9,18,6), 0x6a5845, -30,9,-32);    // Lion's Head
      addMesh(new THREE.ConeGeometry(4,6,4), 0xfafafa, 30,25,-34);     // snow suggestion
      // Table Bay
      addMesh(new THREE.BoxGeometry(80,0.2,18), 0x0d2030, 0,-0.42,-3);
      // Bo-Kaap colourful houses
      const bkCols = [0xe88a6a,0x8ab4a0,0xf0c060,0xcc8844,0x7799bb,0xdd9966,0x88bbaa,0xee9955,0xcc6688,0x66ccaa];
      for (let i=0; i<26; i++) {
        const h=3.5+rng()*3, w=2.5+rng()*2.5;
        const x=-38+i*3+(rng()-0.5)*2, z=-9-(rng()*6);
        buildingsGroup.add(createBuilding(x,z,w,h,w*0.9,bkCols[Math.floor(rng()*bkCols.length)]));
        buildingsGroup.add(createGabledRoof(x,h-0.5,z,w,w*0.9,0x993322));
      }
      // V&A Waterfront grain silos
      for (let s=0; s<9; s++) {
        addMesh(new THREE.CylinderGeometry(2,2,13,16), 0xddddcc, -22+s*2.8,6.5,-12);
        addMesh(new THREE.ConeGeometry(2,3,8), 0xccccbb, -22+s*2.8,14,-12);
      }
      // CBD towers
      addRow(8,-26,12,24,36,[0x4477aa,0x5588bb,0x6699cc]);
      addWindows(buildingsGroup, 0,-26,4,18,4);
    },

    // ── MOSCOW ────────────────────────────────────────────────────────────
    'moscow': function () {
      const moCols = [0x8a8a90,0x9a9aa0,0x7a7a80,0xaaaaaa,0x888890];
      addRow(14,-35,10,18,65,moCols);
      // Moskva river
      addMesh(new THREE.BoxGeometry(80,0.2,10), 0x1a2835, 0,-0.42,-6);
      // Saint Basil's Cathedral — the centrepiece, close and large
      addMesh(new THREE.BoxGeometry(4.5,22,4.5), 0xcc4422, 0,11,-14);
      addMesh(new THREE.CylinderGeometry(2,2.5,3.5,8), 0xcc4422, 0,23,-14);
      const cdom=addMesh(new THREE.SphereGeometry(3,14,14), 0xdd5533, 0,28,-14); cdom.scale.y=1.55;
      addMesh(new THREE.CylinderGeometry(0.25,0.5,2.5,8), 0xddaa44, 0,32,-14);
      const domeColors=[0xcc2222,0x44bb44,0xddaa22,0x3344cc,0xdd2244,0x22aa44,0xccbb00,0x2255bb];
      for (let i=0; i<8; i++) {
        const a=(i/8)*Math.PI*2;
        const dx=Math.cos(a)*7.5, dz=Math.sin(a)*7.5;
        addMesh(new THREE.CylinderGeometry(1.8,1.8,11,8), domeColors[i], dx,5.5,-14+dz);
        const d=addMesh(new THREE.SphereGeometry(2.5,12,12), domeColors[i], dx,12.5,-14+dz); d.scale.y=1.5;
        addMesh(new THREE.CylinderGeometry(0.2,0.35,2,6), 0xddcc88, dx,16,-14+dz);
      }
      // Kremlin wall + Spasskaya tower
      addMesh(new THREE.BoxGeometry(48,5.5,1.8), 0x993322, 0,2.75,-10);
      for (let i=0; i<10; i++) addMesh(new THREE.BoxGeometry(1.3,1.3,2), 0x993322, -22+i*5,6,-10);
      addMesh(new THREE.BoxGeometry(3,24,3), 0x993322, 10,12,-10);
      addMesh(new THREE.ConeGeometry(1.8,5,4), 0x993322, 10,25,-10);
      addMesh(new THREE.SphereGeometry(1.5,8,8), 0xdd1111, 10,28.5,-10, {emissive:0xaa0000, emissiveIntensity:0.7});
      // Moscow City towers
      addRow(8,-36,22,36,50,[0x4477aa,0x3366bb,0x5588cc]);
      // Stalin wedding-cake tower (one big one)
      addMesh(new THREE.BoxGeometry(7,22,7), 0xddcc99, -22,11,-22);
      addMesh(new THREE.BoxGeometry(5.5,9,5.5), 0xddcc99, -22,27,-22);
      addMesh(new THREE.BoxGeometry(4,7,4), 0xddcc99, -22,34,-22);
      addMesh(new THREE.ConeGeometry(0.9,9,4), 0xddaa44, -22,40,-22);
      addWindows(buildingsGroup, -22,-22,7,22,7);
    },

    // ── STOCKHOLM ─────────────────────────────────────────────────────────
    'stockholm': function () {
      const rng = makeRng(23);
      const gmCols = [0xddbb66,0xcc8855,0xee9933,0xddaa44,0xeeddaa,0xcc9944,0xdd8833];
      // Gamla Stan colourful island
      for (let i=0; i<22; i++) {
        const w=2+rng()*2.5, h=5+rng()*6, d=2+rng()*2;
        const x=-32+i*3+(rng()-0.5)*2, z=-11+(rng()-0.5)*2;
        const col=gmCols[Math.floor(rng()*gmCols.length)];
        buildingsGroup.add(createBuilding(x,z,w,h,d,col));
        addWindows(buildingsGroup, x,z,w,h,d);
        buildingsGroup.add(createGabledRoof(x,h-0.5,z,w,d,0x774422));
      }
      addRow(8,-30,14,24,45,[0x88bbdd,0x6699bb,0x7799cc]);
      // Lake Mälaren
      addMesh(new THREE.BoxGeometry(80,0.2,18), 0x1a2a3a, 0,-0.42,-5);
      // City Hall (Stadshuset) — red brick tower with Three Crowns
      addMesh(new THREE.BoxGeometry(16,12,10), 0x8a3a2a, -18,6,-18);
      addMesh(new THREE.BoxGeometry(10,10,10), 0x8a3a2a, -10,5,-18);
      addMesh(new THREE.BoxGeometry(6,32,6), 0x8a3a2a, -14,16,-18);
      addMesh(new THREE.CylinderGeometry(2.5,3,4,8), 0x7a2a1a, -14,33,-18);
      addMesh(new THREE.ConeGeometry(2,4.5,6), 0x998833, -14,37,-18);
      addMesh(new THREE.SphereGeometry(0.95,8,8), 0xddaa44, -14,41.5,-18, {metalness:0.72});
      addMesh(new THREE.SphereGeometry(0.75,8,8), 0xddaa44, -12.2,41,-18, {metalness:0.72});
      addMesh(new THREE.SphereGeometry(0.75,8,8), 0xddaa44, -15.8,41,-18, {metalness:0.72});
      addWindows(buildingsGroup, -14,-18,6,32,6);
      // Riddarholmen church — dark iron spire
      addMesh(new THREE.BoxGeometry(7,7,9), 0x887755, 4,3.5,-16);
      addMesh(new THREE.CylinderGeometry(0.9,1.8,22,8), 0x445533, 4,18,-16);
      addMesh(new THREE.ConeGeometry(0.7,3.5,8), 0x334422, 4,30,-16);
      // Medieval church spires
      [[-6,-14],[16,-18]].forEach(([cx,cz]) => {
        addMesh(new THREE.BoxGeometry(5,7,6), 0x887766, cx,3.5,cz);
        addMesh(new THREE.ConeGeometry(2,12,4), 0x445533, cx,13,cz);
      });
    },

    // ── ZURICH ────────────────────────────────────────────────────────────
    'zurich': function () {
      const rng = makeRng(24);
      const zuCols = [0xddcc99,0xccbb88,0xeedd99,0xddbb77,0xeeccaa,0xddcc88];
      for (let i=0; i<22; i++) {
        const w=1.8+rng()*2.2, h=5+rng()*7, d=2+rng()*2;
        const x=-32+i*3+(rng()-0.5)*2, z=-11+(rng()-0.5)*2;
        buildingsGroup.add(createBuilding(x,z,w,h,d,zuCols[Math.floor(rng()*zuCols.length)]));
        addWindows(buildingsGroup, x,z,w,h,d);
        buildingsGroup.add(createGabledRoof(x,h-0.5,z,w,d,0x664422));
      }
      addRow(6,-30,16,28,40,[0x8899aa,0x99aabb,0x7788aa]);
      // Limmat + Zürichsee
      addMesh(new THREE.BoxGeometry(7,0.2,60), 0x2a4a7a, 0,-0.42,-10);
      addMesh(new THREE.BoxGeometry(80,0.2,16), 0x1a3060, 0,-0.42,-4);
      // Grossmünster — twin Romanesque towers
      addMesh(new THREE.BoxGeometry(9,9,12), 0xaaa080, 0,4.5,-17);
      [-3.5,3.5].forEach(tx => {
        addMesh(new THREE.BoxGeometry(3.5,24,3.5), 0xaaa080, tx,12,-15);
        addMesh(new THREE.CylinderGeometry(2,2.5,4,8), 0x9a9070, tx,25,-15);
        addMesh(new THREE.ConeGeometry(2.5,6,4), 0x887755, tx,29.5,-15);
      });
      addWindows(buildingsGroup, 0,-17,9,9,12);
      // Fraumünster — slender blue-green Gothic spire
      addMesh(new THREE.BoxGeometry(7,7,10), 0x8a806a, 12,3.5,-16);
      addMesh(new THREE.ConeGeometry(1.2,22,4), 0x445544, 12,18,-16);
      // ETH Zürich on the hill
      addMesh(new THREE.BoxGeometry(18,8,12), 0xd0c8b0, -16,4,-18);
      addMesh(new THREE.CylinderGeometry(3.5,4,6,16), 0xb8b090, -16,10,-18);
      const etd=addMesh(new THREE.SphereGeometry(3.5,16,16), 0xaaa880, -16,14,-18); etd.scale.y=0.62;
      addWindows(buildingsGroup, -16,-18,18,8,12);
      // Alps — dominant snow-capped peaks
      [[0,24,-62],[-32,19,-58],[32,20,-58],[-58,13,-52],[58,13,-52]].forEach(([mx,my,mz]) => {
        addMesh(new THREE.ConeGeometry(15,34,4), 0x8a8878, mx,my,mz);
        addMesh(new THREE.ConeGeometry(6.5,10,4), 0xf5f5ff, mx,my+15,mz);
      });
    },

    // ── SÃO PAULO ─────────────────────────────────────────────────────────
    'sao-paulo': function () {
      const rng = makeRng(19);
      const spCols = [0x777777,0x888888,0x666666,0x8a8a90,0x6a6a6a,0x999999];
      addRow(38,-34,14,34,80,spCols);
      addRow(26,-22,10,22,66,spCols);
      addRow(18,-14,6,14,55,spCols);
      // Copan Building — the sinuous S-curved icon
      for (let i=0; i<7; i++) {
        const seg=addMesh(new THREE.BoxGeometry(3,24,3.5), 0x9a9090, -9+i*3,12,-18);
        seg.rotation.y=i*0.1-0.3;
      }
      addWindows(buildingsGroup, -3,-18,3.5,24,3.5);
      // Edifício Itália — Art Deco colossus
      addMesh(new THREE.BoxGeometry(6,26,6), 0xaa9988, 10,13,-20);
      addMesh(new THREE.BoxGeometry(5,10,5), 0xaa9988, 10,31,-20);
      addMesh(new THREE.BoxGeometry(4,8,4), 0xbbaa99, 10,40,-20);
      addMesh(new THREE.CylinderGeometry(0.15,0.5,9,4), 0xbbaa99, 10,48,-20);
      addWindows(buildingsGroup, 10,-20,6,26,6);
      // Banespa Tower
      addMesh(new THREE.BoxGeometry(5,22,5), 0xaaaaaa, -4,11,-22);
      addMesh(new THREE.BoxGeometry(4,7,4), 0xaaaaaa, -4,26.5,-22);
      addMesh(new THREE.ConeGeometry(0.7,8,4), 0xbbbbbb, -4,33.5,-22);
      addWindows(buildingsGroup, -4,-22,5,22,5);
      // Favela colour clusters
      const favCols=[0xcc5544,0xddaa33,0x44aa66,0xcc6633,0x5566cc,0xee8833,0xaa3388,0x33aacc];
      for (let i=0; i<32; i++) {
        const h=2.5+rng()*4, w=1.5+rng()*2.5;
        const side=i<16?-1:1;
        buildingsGroup.add(createBuilding(side*(24+rng()*18),-7-rng()*6,w,h,w*0.9,favCols[Math.floor(rng()*favCols.length)]));
      }
    },

    // ── ROME ──────────────────────────────────────────────────────────────
    'rome': function () {
      const romeCols = [0xcc9944,0xdd8833,0xddcc99,0xd4a050,0xbb8833,0xc89040];
      addRow(22,-24,3,7,72,romeCols);
      addRow(10,-32,5,14,50,[0x8899aa,0x7788aa,0x778899]);
      // Tiber river
      addMesh(new THREE.BoxGeometry(8,0.2,80), 0x1a3040, 20,0,0);
      // Colosseum — the unmistakable elliptical shell
      addMesh(new THREE.BoxGeometry(26,1.8,20), 0xcc9944, -14,0.9,-16);
      addMesh(new THREE.CylinderGeometry(11,11,9,40,1,true), 0xcc9944, -14,4.5,-16, {side:THREE.DoubleSide});
      addMesh(new THREE.CylinderGeometry(9.5,9.5,6,40,1,true), 0xbb8833, -14,3,-16, {side:THREE.DoubleSide});
      addMesh(new THREE.CylinderGeometry(7.5,7.5,4,40,1,true), 0xaa7722, -14,2,-16, {side:THREE.DoubleSide});
      // St Peter's Basilica — the massive dome
      addMesh(new THREE.BoxGeometry(22,8,15), 0xd8d0b8, 6,4,-20);
      addMesh(new THREE.BoxGeometry(20,2,15), 0xd0c8b0, 6,9,-20);
      addMesh(new THREE.CylinderGeometry(7,7,5,24), 0xd8d0b8, 6,14,-20);
      const spd=addMesh(new THREE.SphereGeometry(7.5,24,24), 0xd0c8b0, 6,19,-20); spd.scale.y=0.88;
      addMesh(new THREE.CylinderGeometry(1.2,1.8,3,10), 0xd0c8b0, 6,26,-20);
      addMesh(new THREE.ConeGeometry(0.8,3.5,8), 0xd0c8b0, 6,29,-20);
      addMesh(new THREE.CylinderGeometry(0.18,0.25,3,6), 0xddbb44, 6,32,-20);
      addMesh(new THREE.BoxGeometry(20,6,1.8), 0xd8d0b8, 6,3,-13);
      addMesh(new THREE.BoxGeometry(20,6,1.8), 0xd8d0b8, 6,3,-26);
      addWindows(buildingsGroup, 6,-20,22,8,15);
      // Castel Sant'Angelo
      addMesh(new THREE.CylinderGeometry(7,7,12,24), 0xcc9944, -4,6,-13);
      addMesh(new THREE.BoxGeometry(14,1.8,14), 0xcc9944, -4,12.9,-13);
      addMesh(new THREE.CylinderGeometry(4,4,5,16), 0xbb8833, -4,15.5,-13);
      addMesh(new THREE.CylinderGeometry(0.2,0.25,3,6), 0xddaa44, -4,18.5,-13);
      // Forum columns
      for (let i=0; i<10; i++) {
        const broken=i%3===0;
        addMesh(new THREE.CylinderGeometry(0.3,0.3,broken?3.5:6,8), 0xddc8a0, -4+i*2.2,broken?1.75:3,-14);
      }
    },

    // ── ISTANBUL ──────────────────────────────────────────────────────────
    'istanbul': function () {
      const istCols = [0xcc9944,0xddaa88,0xeeddcc,0xd4b070,0xc8a055,0xdd9944];
      addRow(22,-24,3,8,72,istCols);
      addRow(10,-32,8,18,50,[0x7799aa,0x6688aa,0x8899bb]);
      // Bosphorus
      addMesh(new THREE.BoxGeometry(80,0.2,14), 0x0d2530, 0,-0.42,-5);
      // Hagia Sophia — massive half-dome silhouette
      addMesh(new THREE.BoxGeometry(22,7,18), 0xd4c8a0, -6,3.5,-16);
      addMesh(new THREE.BoxGeometry(20,2,18), 0xd0c0a0, -6,8,-16);
      addMesh(new THREE.CylinderGeometry(9,9,5,24), 0xd4c8a0, -6,13,-16);
      const hsd=addMesh(new THREE.SphereGeometry(10,24,24), 0xddd0b8, -6,18,-16); hsd.scale.y=0.55;
      [[-6,16,-9],[-6,16,-23]].forEach(([hx,hy,hz]) => { const hd=addMesh(new THREE.SphereGeometry(5.5,16,16), 0xd0c8b0, hx,hy,hz); hd.scale.y=0.5; });
      [[-14,5,-10],[-14,5,-22],[2,5,-10],[2,5,-22]].forEach(([mx,my,mz]) => {
        addMesh(new THREE.BoxGeometry(4,13,4), 0xd4c8a0, mx,my+6.5,mz);
      });
      [[-15,0,-10],[-15,0,-22],[3,0,-10],[3,0,-22]].forEach(([mx,my,mz]) => {
        addMesh(new THREE.CylinderGeometry(0.7,0.9,20,8), 0xd4c8a0, mx,10,mz);
        addMesh(new THREE.CylinderGeometry(0.85,0.85,0.7,12), 0xccb890, mx,21,mz);
        addMesh(new THREE.ConeGeometry(0.55,2.8,8), 0xd4c8a0, mx,22.5,mz);
      });
      // Blue Mosque — right side
      addMesh(new THREE.BoxGeometry(20,6,16), 0xd4c8a0, 10,3,-19);
      addMesh(new THREE.CylinderGeometry(7,7,5,24), 0xd4c8a0, 10,11,-19);
      const bmd=addMesh(new THREE.SphereGeometry(7.5,24,24), 0xd0c8b0, 10,15,-19); bmd.scale.y=0.6;
      [[-1,2,-12],[21,2,-12],[-1,2,-26],[21,2,-26],[4.5,2,-19],[15.5,2,-19]].forEach(([mx,my,mz]) => {
        addMesh(new THREE.CylinderGeometry(0.65,0.82,18,8), 0xd4c8a0, mx,9,mz);
        addMesh(new THREE.CylinderGeometry(0.82,0.82,0.7,12), 0xccb890, mx,19,mz);
        addMesh(new THREE.ConeGeometry(0.52,2.5,8), 0xd4c8a0, mx,20.5,mz);
      });
      // Galata Tower
      addMesh(new THREE.CylinderGeometry(3.5,3.5,22,16), 0x9a8a6a, -24,11,-14);
      addMesh(new THREE.CylinderGeometry(4,4,1,16), 0x8a7a5a, -24,23,-14);
      addMesh(new THREE.ConeGeometry(3,6,16), 0x556644, -24,26,-14);
    },

    // ── TEHRAN ────────────────────────────────────────────────────────────
    'tehran': function () {
      const teCols = [0xc8a878,0xd4b888,0xaa9060,0xbb9955,0xc8a060,0xd0aa70];
      addRow(26,-24,4,12,72,teCols);
      addRow(16,-32,8,20,55,[0x8899aa,0x7788aa,0x6677aa,0x99aabb]);
      // Alborz Mountains — Tehran is defined by them
      [[0,24,-62],[-30,19,-58],[30,20,-58],[-55,13,-52],[55,13,-52]].forEach(([mx,my,mz]) => {
        addMesh(new THREE.ConeGeometry(16,35,4), 0x8a8878, mx,my,mz);
        addMesh(new THREE.ConeGeometry(7,10,4), 0xf5f5ff, mx,my+15,mz);
      });
      // Milad Tower — tall shaft + observation head
      addMesh(new THREE.BoxGeometry(8,12,8), 0xd4c8a0, 0,6,-18);
      addMesh(new THREE.BoxGeometry(6,2.5,6), 0xbbbb00, 0,13,-18);
      addMesh(new THREE.CylinderGeometry(0.65,0.88,40,12), 0xdddddd, 0,34,-18, {metalness:0.35, roughness:0.5});
      addMesh(new THREE.CylinderGeometry(6,7,7,16), 0xaabbcc, 0,58,-18, {metalness:0.55, roughness:0.3});
      addMesh(new THREE.CylinderGeometry(5,6,5.5,16), 0x99aacc, 0,63.5,-18, {metalness:0.55});
      addMesh(new THREE.CylinderGeometry(3.5,3.5,3.5,14), 0x889aab, 0,68,-18);
      addMesh(new THREE.CylinderGeometry(0.1,0.25,18,8), 0xdddddd, 0,77,-18);
      addWindows(buildingsGroup, 0,-18,8,12,8);
      // Azadi Tower — iconic white arch up close
      addMesh(new THREE.BoxGeometry(14,2.5,6), 0xf0ece0, 0,1.25,-13);
      const aL=addMesh(new THREE.BoxGeometry(3,18,4), 0xf0ece0, -5,10,-13); aL.rotation.z=0.26;
      const aR=addMesh(new THREE.BoxGeometry(3,18,4), 0xf0ece0,  5,10,-13); aR.rotation.z=-0.26;
      addMesh(new THREE.BoxGeometry(6,4,4), 0xf0ece0, 0,17.5,-13);
      addMesh(new THREE.CylinderGeometry(1.5,2,5.5,8), 0xf0ece0, 0,21.5,-13);
      addMesh(new THREE.ConeGeometry(1.2,3,8), 0xe8e4d8, 0,25,-13);
      // Golestan Palace
      addMesh(new THREE.BoxGeometry(20,5.5,9), 0xd4b878, -17,2.75,-16);
      addMesh(new THREE.BoxGeometry(18,2,9.5), 0xc8aa66, -17,6,-16);
      addMesh(new THREE.BoxGeometry(6,9,1.4), 0xd4b878, -17,4.5,-12);
      addMesh(new THREE.TorusGeometry(2.2,0.5,8,28,Math.PI), 0xc8aa66, -17,8,-12);
      [-22,-17,-12].forEach(dx => { const pd=addMesh(new THREE.SphereGeometry(1.4,12,12), 0x66aa88, dx,8,-16); pd.scale.y=0.65; });
      // Mosque minarets
      [[-9,-18],[22,-17],[-25,-14],[14,-20]].forEach(([mx,mz]) => {
        addMesh(new THREE.CylinderGeometry(0.45,0.58,16,8), 0xd4c8a0, mx,8,mz);
        addMesh(new THREE.CylinderGeometry(0.72,0.72,0.7,12), 0xc8b890, mx,17,mz);
        addMesh(new THREE.ConeGeometry(0.45,3,8), 0x66aa55, mx,18.7,mz);
      });
    },

  }; // end CITY_SKYLINES

  // ---------------------------------------------------------------------------
  // Pedestrians — tiny figures walking along street lanes
  // ---------------------------------------------------------------------------
  const pedestriansGroup = new THREE.Group();
  scene.add(pedestriansGroup);

  const PERSON_BODY_COLORS = [0x2255aa, 0xaa3322, 0x226633, 0x885522, 0x553388, 0x226688, 0xaa6622, 0x334444, 0x884444, 0x448844];

  const UMBRELLA_COLORS = [0xee4444, 0x4444ee, 0x44cc44, 0xeebb22, 0xcc44cc, 0x44cccc, 0xee8833, 0xffffff];

  function createPerson(color) {
    const group = new THREE.Group();
    const bodyMat = new THREE.MeshStandardMaterial({ color, roughness: 0.9 });
    const body = new THREE.Mesh(new THREE.CylinderGeometry(0.11, 0.14, 0.62, 6), bodyMat);
    body.position.y = 0.31;
    body.castShadow = true;
    group.add(body);
    const headMat = new THREE.MeshStandardMaterial({ color: 0xd4a882, roughness: 0.8 });
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.13, 6, 6), headMat);
    head.position.y = 0.75;
    head.castShadow = true;
    group.add(head);
    // Umbrella — shown during rain
    const umbrellaColor = UMBRELLA_COLORS[Math.floor(Math.random() * UMBRELLA_COLORS.length)];
    const umbrella = new THREE.Mesh(
      new THREE.ConeGeometry(0.38, 0.22, 8, 1, true),
      new THREE.MeshStandardMaterial({ color: umbrellaColor, roughness: 0.8, side: THREE.DoubleSide })
    );
    umbrella.rotation.x = Math.PI;
    umbrella.position.y = 1.08;
    umbrella.visible = false;
    group.add(umbrella);
    group.userData.umbrella = umbrella;
    return group;
  }

  // [z, xMin, xMax, zJitter] — two sidewalk lanes in the foreground
  const STREET_LANES = [
    [-9.2,  -30, 30, 0.8],
    [-12.8, -26, 26, 0.8],
  ];

  const pedestrians = [];

  function getCrowdDensity() {
    try {
      const tz = CITIES[currentCityKey].tz;
      const h = parseInt(new Date().toLocaleString('en-US', { timeZone: tz, hour: 'numeric', hour12: false })) || 12;
      if ((h >= 7 && h < 9) || (h >= 17 && h < 19)) return 'rush';
      if (h >= 23 || h < 5) return 'night';
      return 'normal';
    } catch (e) { return 'normal'; }
  }

  function spawnPedestrians() {
    while (pedestriansGroup.children.length > 0) {
      pedestriansGroup.remove(pedestriansGroup.children[0]);
    }
    pedestrians.length = 0;
    const density = getCrowdDensity();
    const count = density === 'rush' ? 65 : density === 'night' ? 10 : 42;
    for (let i = 0; i < count; i++) {
      const lane = STREET_LANES[i % STREET_LANES.length];
      const [laneZ, xMin, xMax, jitter] = lane;
      const color = PERSON_BODY_COLORS[Math.floor(Math.random() * PERSON_BODY_COLORS.length)];
      const mesh = createPerson(color);
      const x = xMin + Math.random() * (xMax - xMin);
      const z = laneZ + (Math.random() - 0.5) * jitter;
      mesh.position.set(x, 0, z);
      const dir = Math.random() > 0.5 ? 1 : -1;
      mesh.rotation.y = dir > 0 ? 0 : Math.PI;
      pedestriansGroup.add(mesh);
      pedestrians.push({ mesh, xMin, xMax, dir, speed: 0.7 + Math.random() * 1.1, phase: Math.random() * Math.PI * 2 });
    }
  }

  // ---------------------------------------------------------------------------
  // Cars — rolling along a road lane between the sidewalks
  // ---------------------------------------------------------------------------
  const carsGroup = new THREE.Group();
  scene.add(carsGroup);

  const CAR_COLORS = [0xcc2222, 0x2244cc, 0xeecc22, 0x228833, 0xcc8822, 0xcccccc, 0x222222, 0x44aacc];

  function createCar(color) {
    const g = new THREE.Group();
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(1.4, 0.44, 0.7),
      new THREE.MeshStandardMaterial({ color, roughness: 0.55, metalness: 0.35 })
    );
    body.position.y = 0.3;
    g.add(body);
    const cabin = new THREE.Mesh(
      new THREE.BoxGeometry(0.78, 0.34, 0.64),
      new THREE.MeshStandardMaterial({ color: 0x334455, roughness: 0.3, metalness: 0.5, transparent: true, opacity: 0.85 })
    );
    cabin.position.set(-0.05, 0.62, 0);
    g.add(cabin);
    const hlMat = new THREE.MeshStandardMaterial({ color: 0xffffcc, emissive: 0xffffaa, emissiveIntensity: 0.8 });
    [-0.26, 0.26].forEach(zo => {
      const hl = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.1, 0.07), hlMat);
      hl.position.set(0.72, 0.3, zo);
      g.add(hl);
    });
    // Headlight road beam — additive cone on the ground in front of the car
    const beamMat = new THREE.MeshBasicMaterial({
      color: 0xffffff, transparent: true, opacity: 0,
      blending: THREE.AdditiveBlending, depthWrite: false,
    });
    g.userData.beamMat = beamMat;
    const beam = new THREE.Mesh(new THREE.PlaneGeometry(4.5, 1.3), beamMat);
    beam.rotation.x = -Math.PI / 2;
    beam.position.set(3.0, 0.03, 0);
    g.add(beam);
    return g;
  }

  const cars = [];
  const CAR_LANES = [
    { z: -10.6, xMin: -38, xMax: 38, dir: 1 },
    { z: -11.4, xMin: -38, xMax: 38, dir: -1 },
  ];

  function spawnCars() {
    while (carsGroup.children.length > 0) carsGroup.remove(carsGroup.children[0]);
    cars.length = 0;
    CAR_LANES.forEach(lane => {
      const cDensity = getCrowdDensity();
      const carsPerLane = cDensity === 'rush' ? 9 : cDensity === 'night' ? 2 : 5;
      for (let i = 0; i < carsPerLane; i++) {
        const color = CAR_COLORS[Math.floor(Math.random() * CAR_COLORS.length)];
        const mesh = createCar(color);
        mesh.position.set(lane.xMin + Math.random() * (lane.xMax - lane.xMin), 0, lane.z);
        if (lane.dir < 0) mesh.rotation.y = Math.PI;
        carsGroup.add(mesh);
        cars.push({ mesh, xMin: lane.xMin, xMax: lane.xMax, dir: lane.dir, speed: 3.5 + Math.random() * 4, beamMat: mesh.userData.beamMat });
      }
    });
  }

  // ---------------------------------------------------------------------------
  // Boats — gliding along the city waterway
  // ---------------------------------------------------------------------------
  const boatsGroup = new THREE.Group();
  scene.add(boatsGroup);

  const BOAT_WATER_Z = {
    'amsterdam': -7, 'london': -7, 'paris': -7, 'berlin': -7,
    'new-york': -5, 'toronto': -4, 'seoul': -5, 'bangkok': -6,
    'dubai': -4, 'singapore': -5, 'mumbai': -5, 'sydney': 2,
    'moscow': -7, 'istanbul': -6, 'stockholm': -6,
  };

  function createBoat(color) {
    const g = new THREE.Group();
    const hull = new THREE.Mesh(
      new THREE.BoxGeometry(2.2, 0.34, 0.88),
      new THREE.MeshStandardMaterial({ color, roughness: 0.8 })
    );
    hull.position.y = 0.17;
    g.add(hull);
    const cabin = new THREE.Mesh(
      new THREE.BoxGeometry(0.85, 0.38, 0.72),
      new THREE.MeshStandardMaterial({ color: 0xeeeedd, roughness: 0.7 })
    );
    cabin.position.set(-0.2, 0.54, 0);
    g.add(cabin);
    return g;
  }

  const boats = [];
  const BOAT_COLORS = [0xcc4422, 0x2255aa, 0x225533, 0xccaa33, 0x888888, 0xaa3355];

  function spawnBoats() {
    while (boatsGroup.children.length > 0) boatsGroup.remove(boatsGroup.children[0]);
    boats.length = 0;
    const waterZ = BOAT_WATER_Z[currentCityKey];
    if (waterZ === undefined) return;
    const waterY = waterZ === 2 ? 1.0 : -0.22;
    for (let i = 0; i < 6; i++) {
      const color = BOAT_COLORS[i % BOAT_COLORS.length];
      const mesh = createBoat(color);
      const dir = i % 2 === 0 ? 1 : -1;
      mesh.position.set(-35 + Math.random() * 70, waterY, waterZ);
      if (dir < 0) mesh.rotation.y = Math.PI;
      boatsGroup.add(mesh);
      boats.push({ mesh, xMin: -40, xMax: 40, dir, speed: 0.8 + Math.random() * 0.9, baseY: waterY });
    }
  }

  // ---------------------------------------------------------------------------
  // Birds — orbiting the city skyline
  // ---------------------------------------------------------------------------
  const birdsGroup = new THREE.Group();
  scene.add(birdsGroup);

  const birdData = [];
  for (let i = 0; i < 8; i++) {
    const wing = new THREE.Mesh(
      new THREE.BoxGeometry(0.55, 0.06, 0.18),
      new THREE.MeshStandardMaterial({ color: 0x222222, roughness: 1 })
    );
    birdsGroup.add(wing);
    birdData.push({
      mesh: wing,
      orbitRadius: 5 + Math.random() * 7,
      orbitSpeed:  0.28 + Math.random() * 0.22,
      orbitPhase:  (i / 8) * Math.PI * 2,
      heightBase:  15 + Math.random() * 10,
      heightAmp:   1.2 + Math.random() * 2,
      heightPhase: Math.random() * Math.PI * 2,
      flapPhase:   Math.random() * Math.PI * 2,
    });
  }

  // ---------------------------------------------------------------------------
  // Snow caps on rooftops
  // ---------------------------------------------------------------------------
  function spawnSnowCaps() {
    while (snowCapsGroup.children.length > 0) snowCapsGroup.remove(snowCapsGroup.children[0]);
    snowCapMats.length = 0;
    for (const r of buildingRoofs) {
      const mat = new THREE.MeshStandardMaterial({ color: 0xeef0ff, roughness: 1, transparent: true, opacity: 0 });
      snowCapMats.push(mat);
      const cap = new THREE.Mesh(new THREE.BoxGeometry(r.w + 0.08, 0.2, r.d + 0.08), mat);
      cap.position.set(r.x, r.h - 0.4, r.z);
      snowCapsGroup.add(cap);
    }
  }

  // ---------------------------------------------------------------------------
  // Street lamps
  // ---------------------------------------------------------------------------
  function spawnLamps() {
    while (lampsGroup.children.length > 0) lampsGroup.remove(lampsGroup.children[0]);
    lampBulbMats.length = 0;
    lampPoolMats.length = 0;
    [[-9.2, 1], [-12.8, -1]].forEach(([lz, side]) => {
      for (let lx = -27; lx <= 27; lx += 5) {
        const pole = new THREE.Mesh(
          new THREE.CylinderGeometry(0.055, 0.07, 2.2, 6),
          new THREE.MeshStandardMaterial({ color: 0x444455, roughness: 0.8 })
        );
        pole.position.set(lx, 1.1, lz);
        lampsGroup.add(pole);
        const arm = new THREE.Mesh(
          new THREE.BoxGeometry(0.35, 0.055, 0.055),
          new THREE.MeshStandardMaterial({ color: 0x444455 })
        );
        arm.position.set(lx + side * 0.18, 2.28, lz);
        lampsGroup.add(arm);
        const bulbMat = new THREE.MeshStandardMaterial({ color: 0xffeeaa, emissive: 0xffcc44, emissiveIntensity: 0, roughness: 1 });
        lampBulbMats.push(bulbMat);
        const bulb = new THREE.Mesh(new THREE.SphereGeometry(0.1, 6, 6), bulbMat);
        bulb.position.set(lx + side * 0.35, 2.28, lz);
        lampsGroup.add(bulb);
        // Ground light pool — soft warm circle on the road surface
        const poolMat = new THREE.MeshBasicMaterial({
          color: 0xffdd88, transparent: true, opacity: 0,
          blending: THREE.AdditiveBlending, depthWrite: false,
        });
        lampPoolMats.push(poolMat);
        const pool = new THREE.Mesh(new THREE.CircleGeometry(2.0, 16), poolMat);
        pool.rotation.x = -Math.PI / 2;
        pool.position.set(lx + side * 0.35, 0.03, lz);
        lampsGroup.add(pool);
      }
    });
  }

  // ---------------------------------------------------------------------------
  // Neon signs
  // ---------------------------------------------------------------------------
  function spawnNeonSigns() {
    while (neonsGroup.children.length > 0) neonsGroup.remove(neonsGroup.children[0]);
    neonSignData.length = 0;
    if (!NEON_CITIES.has(currentCityKey)) return;
    for (let i = 0; i < 22; i++) {
      const color = NEON_PALETTE[Math.floor(Math.random() * NEON_PALETTE.length)];
      const w = 0.7 + Math.random() * 1.4;
      const h = 0.25 + Math.random() * 0.35;
      const mat = new THREE.MeshStandardMaterial({ color, emissive: color, emissiveIntensity: 0, roughness: 1 });
      neonSignData.push({ mat, flickerPhase: Math.random() * Math.PI * 2, flickerSpeed: 2.5 + Math.random() * 5 });
      const sign = new THREE.Mesh(new THREE.PlaneGeometry(w, h), mat);
      sign.position.set((Math.random() - 0.5) * 48, 1.5 + Math.random() * 7, -9.5 - Math.random() * 9);
      neonsGroup.add(sign);
    }
  }

  // ---------------------------------------------------------------------------
  // Flags
  // ---------------------------------------------------------------------------
  function spawnFlags() {
    while (flagsGroup.children.length > 0) flagsGroup.remove(flagsGroup.children[0]);
    flagData.length = 0;
    const poles = CITY_FLAG_POLES[currentCityKey] || defaultFlagPoles;
    poles.forEach(([px, py, pz]) => {
      const tip = new THREE.Mesh(
        new THREE.SphereGeometry(0.08, 6, 6),
        new THREE.MeshStandardMaterial({ color: 0xddaa44, metalness: 0.7 })
      );
      tip.position.set(px, py, pz);
      flagsGroup.add(tip);
      const color = FLAG_COLORS[Math.floor(Math.random() * FLAG_COLORS.length)];
      const geo = new THREE.PlaneGeometry(1.4, 0.7, 8, 4);
      const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.9, side: THREE.DoubleSide });
      const flag = new THREE.Mesh(geo, mat);
      flag.position.set(px + 0.7, py - 0.1, pz);
      flagsGroup.add(flag);
      flagData.push({ geo, anchorX: px, anchorY: py - 0.1, anchorZ: pz });
    });
  }

  // ── Switch city skyline ────────────────────────────────────────────────
  function switchCityVisuals(cityKey) {
    while (buildingsGroup.children.length > 0) {
      buildingsGroup.remove(buildingsGroup.children[0]);
    }
    allWindowMats.length = 0;
    buildingRoofs.length = 0;
    mxFlashMats.length = 0;
    const fn = CITY_SKYLINES[cityKey] || CITY_SKYLINES['amsterdam'];
    fn();
    spawnPedestrians();
    spawnCars();
    spawnBoats();
    spawnSnowCaps();
    spawnLamps();
    spawnNeonSigns();
    spawnFlags();
  }

  // Detect initial city from browser timezone
  try {
    const browserTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const detected = detectCityFromTimezone(browserTz);
    currentCityKey = detected;
    const picker = document.getElementById('city-picker');
    if (picker) picker.value = detected;
  } catch (e) { /* keep amsterdam */ }

  switchCityVisuals(currentCityKey);

  // ---------------------------------------------------------------------------
  // Sun mesh
  // ---------------------------------------------------------------------------
  const sunGeo = new THREE.SphereGeometry(2.5, 32, 32);
  const sunMat = new THREE.MeshBasicMaterial({ color: 0xffee88 });
  const sunMesh = new THREE.Mesh(sunGeo, sunMat);
  sunMesh.position.set(12, 22, -40);
  scene.add(sunMesh);

  // Sun glow sprite
  const glowCanvas = document.createElement("canvas");
  glowCanvas.width = 256;
  glowCanvas.height = 256;
  const gCtx = glowCanvas.getContext("2d");
  const grad = gCtx.createRadialGradient(128, 128, 0, 128, 128, 128);
  grad.addColorStop(0, "rgba(255,240,180,0.6)");
  grad.addColorStop(0.4, "rgba(255,200,100,0.15)");
  grad.addColorStop(1, "rgba(255,200,100,0)");
  gCtx.fillStyle = grad;
  gCtx.fillRect(0, 0, 256, 256);
  const glowTex = new THREE.CanvasTexture(glowCanvas);
  const glowMat = new THREE.SpriteMaterial({ map: glowTex, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.8 });
  const sunGlow = new THREE.Sprite(glowMat);
  sunGlow.scale.set(18, 18, 1);
  sunGlow.position.copy(sunMesh.position);
  scene.add(sunGlow);

  // ---------------------------------------------------------------------------
  // Stars, Moon, Shooting star
  // ---------------------------------------------------------------------------
  const STAR_COUNT = 800;
  const starPos = new Float32Array(STAR_COUNT * 3);
  for (let i = 0; i < STAR_COUNT; i++) {
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    const r = 115 + Math.random() * 20;
    starPos[i*3]     = r * Math.sin(phi) * Math.cos(theta);
    starPos[i*3 + 1] = Math.abs(r * Math.cos(phi)) + 5;
    starPos[i*3 + 2] = r * Math.sin(phi) * Math.sin(theta);
  }
  const starGeo = new THREE.BufferGeometry();
  starGeo.setAttribute('position', new THREE.BufferAttribute(starPos, 3));
  const starsMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.55, sizeAttenuation: false, transparent: true, opacity: 0 });
  const starsSystem = new THREE.Points(starGeo, starsMat);
  scene.add(starsSystem);

  const moonMesh = new THREE.Mesh(
    new THREE.SphereGeometry(2.2, 16, 16),
    new THREE.MeshBasicMaterial({ color: 0xeeeedd, transparent: true, opacity: 0 })
  );
  moonMesh.position.set(-14, 24, -45);
  scene.add(moonMesh);

  const moonGlowCanvas = document.createElement('canvas');
  moonGlowCanvas.width = 128; moonGlowCanvas.height = 128;
  const mgCtx = moonGlowCanvas.getContext('2d');
  const mgGrad = mgCtx.createRadialGradient(64,64,0,64,64,64);
  mgGrad.addColorStop(0, 'rgba(210,210,190,0.3)');
  mgGrad.addColorStop(1, 'rgba(210,210,190,0)');
  mgCtx.fillStyle = mgGrad; mgCtx.fillRect(0,0,128,128);
  const moonGlowMat = new THREE.SpriteMaterial({ map: new THREE.CanvasTexture(moonGlowCanvas), blending: THREE.AdditiveBlending, transparent: true, opacity: 0 });
  const moonGlow = new THREE.Sprite(moonGlowMat);
  moonGlow.scale.set(14, 14, 1);
  moonGlow.position.copy(moonMesh.position);
  scene.add(moonGlow);

  // Shooting star
  let shootingStarTimer = 0;
  let nextShootingStar = 12 + Math.random() * 18;
  let sStarActive = false, sStarProgress = 0;
  let sStarX0 = 0, sStarY0 = 0, sStarZ0 = 0, sStarDX = 0, sStarDY = 0;
  const sStarPts = new Float32Array(6);
  const sStarGeo = new THREE.BufferGeometry();
  sStarGeo.setAttribute('position', new THREE.BufferAttribute(sStarPts, 3));
  const sStarMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0 });
  const sStarLine = new THREE.Line(sStarGeo, sStarMat);
  scene.add(sStarLine);

  // ---------------------------------------------------------------------------
  // Cloud system
  // ---------------------------------------------------------------------------
  const cloudsGroup = new THREE.Group();
  scene.add(cloudsGroup);

  function createCloud(x, y, z, scale) {
    const group = new THREE.Group();
    const mat = new THREE.MeshStandardMaterial({ color: 0xcccdd5, roughness: 1, metalness: 0, transparent: true, opacity: 0.85 });
    const puffs = 4 + Math.floor(Math.random() * 4);
    for (let i = 0; i < puffs; i++) {
      const r = 1.0 + Math.random() * 1.5;
      const geo = new THREE.SphereGeometry(r, 12, 12);
      const puff = new THREE.Mesh(geo, mat);
      puff.position.set((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 1.0, (Math.random() - 0.5) * 2);
      puff.scale.y *= 0.6;
      group.add(puff);
    }
    group.position.set(x, y, z);
    group.scale.setScalar(scale);
    group.userData.speed = 0.1 + Math.random() * 0.15;
    group.userData.startX = x;
    return group;
  }

  const cloudInstances = [];
  for (let i = 0; i < 14; i++) {
    const x = (Math.random() - 0.5) * 80;
    const y = 14 + Math.random() * 8;
    const z = -15 - Math.random() * 35;
    const s = 0.7 + Math.random() * 1.0;
    const c = createCloud(x, y, z, s);
    cloudsGroup.add(c);
    cloudInstances.push(c);
  }

  // ---------------------------------------------------------------------------
  // Particle systems — rain, snow, sun particles
  // ---------------------------------------------------------------------------
  // Rain
  const RAIN_COUNT = 6000;
  const rainGeo = new THREE.BufferGeometry();
  const rainPositions = new Float32Array(RAIN_COUNT * 3);
  for (let i = 0; i < RAIN_COUNT; i++) {
    rainPositions[i * 3] = (Math.random() - 0.5) * 80;
    rainPositions[i * 3 + 1] = Math.random() * 40;
    rainPositions[i * 3 + 2] = (Math.random() - 0.5) * 60;
  }
  rainGeo.setAttribute("position", new THREE.BufferAttribute(rainPositions, 3));
  const rainMat = new THREE.PointsMaterial({ color: 0xaabbdd, size: 0.12, transparent: true, opacity: 0.6, depthWrite: false });
  const rainSystem = new THREE.Points(rainGeo, rainMat);
  rainSystem.visible = false;
  scene.add(rainSystem);

  // Snow
  const SNOW_COUNT = 4000;
  const snowGeo = new THREE.BufferGeometry();
  const snowPositions = new Float32Array(SNOW_COUNT * 3);
  for (let i = 0; i < SNOW_COUNT; i++) {
    snowPositions[i * 3] = (Math.random() - 0.5) * 80;
    snowPositions[i * 3 + 1] = Math.random() * 40;
    snowPositions[i * 3 + 2] = (Math.random() - 0.5) * 60;
  }
  snowGeo.setAttribute("position", new THREE.BufferAttribute(snowPositions, 3));
  const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.85, depthWrite: false });
  const snowSystem = new THREE.Points(snowGeo, snowMat);
  snowSystem.visible = false;
  scene.add(snowSystem);

  // Sun floating particles
  const SUN_P_COUNT = 800;
  const sunPGeo = new THREE.BufferGeometry();
  const sunPPositions = new Float32Array(SUN_P_COUNT * 3);
  for (let i = 0; i < SUN_P_COUNT; i++) {
    sunPPositions[i * 3] = (Math.random() - 0.5) * 80;
    sunPPositions[i * 3 + 1] = Math.random() * 25;
    sunPPositions[i * 3 + 2] = (Math.random() - 0.5) * 50;
  }
  sunPGeo.setAttribute("position", new THREE.BufferAttribute(sunPPositions, 3));
  const sunPMat = new THREE.PointsMaterial({ color: 0xffeebb, size: 0.08, transparent: true, opacity: 0.4, depthWrite: false, blending: THREE.AdditiveBlending });
  const sunParticles = new THREE.Points(sunPGeo, sunPMat);
  sunParticles.visible = false;
  scene.add(sunParticles);

  // ---------------------------------------------------------------------------
  // Lightning flash (for thunderstorms)
  // ---------------------------------------------------------------------------
  const lightningLight = new THREE.PointLight(0xccccff, 0, 100);
  lightningLight.position.set(0, 25, -15);
  scene.add(lightningLight);
  let lightningTimer = 0;
  let nextLightning = 3 + Math.random() * 5;

  // ---------------------------------------------------------------------------
  // Skybox gradient via large sphere
  // ---------------------------------------------------------------------------
  const skyGeo = new THREE.SphereGeometry(150, 32, 32);
  const skyVertCount = skyGeo.attributes.position.count;
  const skyColors = new Float32Array(skyVertCount * 3);
  skyGeo.setAttribute("color", new THREE.BufferAttribute(skyColors, 3));
  const skyMat = new THREE.MeshBasicMaterial({ vertexColors: true, side: THREE.BackSide, fog: false });
  const skyMesh = new THREE.Mesh(skyGeo, skyMat);
  scene.add(skyMesh);

  // ---------------------------------------------------------------------------
  // Night / day mode
  // ---------------------------------------------------------------------------
  let nightFactor = 0; // 0 = full day, 1 = full night

  function updateNightFactor() {
    try {
      const tz = CITIES[currentCityKey].tz;
      const localHour = parseInt(new Date().toLocaleString('en-US', { timeZone: tz, hour: 'numeric', hour12: false })) || 12;
      if (localHour >= 8 && localHour < 18) nightFactor = 0;
      else if (localHour >= 20 || localHour < 6) nightFactor = 1;
      else if (localHour >= 18) nightFactor = (localHour - 18) / 2;
      else nightFactor = 1 - (localHour - 6) / 2;
    } catch (e) { nightFactor = 0; }
  }

  function getEffectivePalette() {
    const nf = nightFactor;
    if (nf === 0) return targetPalette;
    const np = { top: [0.02, 0.02, 0.08], mid: [0.03, 0.04, 0.10], bottom: [0.05, 0.06, 0.14] };
    return {
      top:    targetPalette.top.map((v, i) => v * (1 - nf) + np.top[i] * nf),
      mid:    targetPalette.mid.map((v, i) => v * (1 - nf) + np.mid[i] * nf),
      bottom: targetPalette.bottom.map((v, i) => v * (1 - nf) + np.bottom[i] * nf),
    };
  }

  // Colour palettes per condition { top, mid, bottom }
  const skyPalettes = {
    clear:  { top: [0.15, 0.30, 0.70], mid: [0.45, 0.60, 0.85], bottom: [0.85, 0.70, 0.55] },
    cloudy: { top: [0.35, 0.38, 0.45], mid: [0.50, 0.52, 0.56], bottom: [0.58, 0.57, 0.55] },
    rain:   { top: [0.12, 0.13, 0.18], mid: [0.22, 0.24, 0.30], bottom: [0.30, 0.30, 0.32] },
    snow:   { top: [0.55, 0.58, 0.65], mid: [0.68, 0.70, 0.74], bottom: [0.78, 0.78, 0.80] },
    fog:    { top: [0.50, 0.52, 0.54], mid: [0.58, 0.59, 0.60], bottom: [0.62, 0.62, 0.63] },
    thunder:{ top: [0.06, 0.06, 0.10], mid: [0.14, 0.14, 0.20], bottom: [0.22, 0.20, 0.24] },
  };

  // Current interpolated palette (start with cloudy)
  const currentPalette = {
    top: [...skyPalettes.cloudy.top],
    mid: [...skyPalettes.cloudy.mid],
    bottom: [...skyPalettes.cloudy.bottom],
  };
  let targetPalette = skyPalettes.cloudy;

  function lerpArr(a, b, t) {
    for (let i = 0; i < a.length; i++) a[i] += (b[i] - a[i]) * t;
  }

  function applySkyColors() {
    const pos = skyGeo.attributes.position;
    const col = skyGeo.attributes.color;
    for (let i = 0; i < skyVertCount; i++) {
      const y = pos.getY(i);
      const t = THREE.MathUtils.clamp((y + 150) / 300, 0, 1); // 0=bottom, 1=top
      let r, g, b;
      if (t < 0.5) {
        const lt = t / 0.5;
        r = THREE.MathUtils.lerp(currentPalette.bottom[0], currentPalette.mid[0], lt);
        g = THREE.MathUtils.lerp(currentPalette.bottom[1], currentPalette.mid[1], lt);
        b = THREE.MathUtils.lerp(currentPalette.bottom[2], currentPalette.mid[2], lt);
      } else {
        const lt = (t - 0.5) / 0.5;
        r = THREE.MathUtils.lerp(currentPalette.mid[0], currentPalette.top[0], lt);
        g = THREE.MathUtils.lerp(currentPalette.mid[1], currentPalette.top[1], lt);
        b = THREE.MathUtils.lerp(currentPalette.mid[2], currentPalette.top[2], lt);
      }
      col.setXYZ(i, r, g, b);
    }
    col.needsUpdate = true;
  }

  applySkyColors();

  // ---------------------------------------------------------------------------
  // Condition state
  // ---------------------------------------------------------------------------
  let currentCondition = "cloudy";

  // Target opacity / visibility values that we lerp toward
  const targets = {
    sunOpacity: 0,
    sunGlowOpacity: 0,
    sunParticlesOpacity: 0,
    cloudOpacity: 0.85,
    rainOpacity: 0,
    snowOpacity: 0,
    fogDensity: 0.008,
    ambientIntensity: 0.4,
    dirIntensity: 1.0,
    dirColor: new THREE.Color(0xffeedd),
    ambientColor: new THREE.Color(0x8899bb),
    exposure: 1.0,
  };

  function setConditionTargets(cond) {
    currentCondition = cond;
    targetPalette = skyPalettes[cond] || skyPalettes.cloudy;

    // Reset all
    targets.sunOpacity = 0;
    targets.sunGlowOpacity = 0;
    targets.sunParticlesOpacity = 0;
    targets.cloudOpacity = 0;
    targets.rainOpacity = 0;
    targets.snowOpacity = 0;
    targets.fogDensity = 0.008;
    targets.ambientIntensity = 0.5;
    targets.dirIntensity = 0.8;
    targets.dirColor.set(0xffeedd);
    targets.ambientColor.set(0x8899bb);
    targets.exposure = 1.0;

    switch (cond) {
      case "clear":
        targets.sunOpacity = 1;
        targets.sunGlowOpacity = 0.9;
        targets.sunParticlesOpacity = 0.4;
        targets.cloudOpacity = 0.15;
        targets.dirIntensity = 1.4;
        targets.ambientIntensity = 0.6;
        targets.exposure = 1.2;
        targets.dirColor.set(0xffeecc);
        targets.ambientColor.set(0x99aadd);
        break;
      case "cloudy":
        targets.cloudOpacity = 0.85;
        targets.sunOpacity = 0.3;
        targets.sunGlowOpacity = 0.2;
        targets.dirIntensity = 0.6;
        targets.ambientIntensity = 0.55;
        break;
      case "rain":
        targets.cloudOpacity = 0.9;
        targets.rainOpacity = 0.6;
        targets.fogDensity = 0.015;
        targets.dirIntensity = 0.35;
        targets.ambientIntensity = 0.4;
        targets.exposure = 0.75;
        targets.dirColor.set(0xaabbcc);
        targets.ambientColor.set(0x667788);
        break;
      case "thunder":
        targets.cloudOpacity = 0.95;
        targets.rainOpacity = 0.7;
        targets.fogDensity = 0.018;
        targets.dirIntensity = 0.2;
        targets.ambientIntensity = 0.25;
        targets.exposure = 0.6;
        targets.dirColor.set(0x8888aa);
        targets.ambientColor.set(0x445566);
        break;
      case "snow":
        targets.cloudOpacity = 0.7;
        targets.snowOpacity = 0.85;
        targets.fogDensity = 0.02;
        targets.dirIntensity = 0.6;
        targets.ambientIntensity = 0.65;
        targets.exposure = 1.1;
        targets.dirColor.set(0xddeeff);
        targets.ambientColor.set(0xbbccdd);
        break;
      case "fog":
        targets.cloudOpacity = 0.3;
        targets.fogDensity = 0.045;
        targets.dirIntensity = 0.35;
        targets.ambientIntensity = 0.5;
        targets.exposure = 0.8;
        targets.dirColor.set(0xcccccc);
        targets.ambientColor.set(0x999999);
        break;
    }
  }

  setConditionTargets("cloudy"); // initial

  // ---------------------------------------------------------------------------
  // UI update
  // ---------------------------------------------------------------------------
  function updateUI(data) {
    const c = data.current;
    const code = c.weather_code;
    const desc = WMO_DESCRIPTIONS[code] || "Unknown";
    const cityName = CITIES[currentCityKey].name;

    // Update city name in overlay
    document.querySelector(".city-name").textContent = cityName;

    document.getElementById("weather-desc").textContent = desc;
    document.getElementById("temperature").innerHTML = Math.round(c.temperature_2m) + '<sup>&deg;C</sup>';
    document.getElementById("feels-like").textContent = Math.round(c.apparent_temperature) + "\u00B0C";
    document.getElementById("humidity").textContent = c.relative_humidity_2m + "%";
    currentWindSpeed = c.wind_speed_10m;
    document.getElementById("wind").textContent = Math.round(c.wind_speed_10m) + " km/h";

    const now = new Date();
    document.getElementById("timestamp").textContent =
      cityName + " \u2014 updated " + now.toLocaleTimeString("en-GB", { hour: "2-digit", minute: "2-digit" });

    // Apply condition
    setConditionTargets(classifyWeather(code));
    updateNightFactor();
    targets.dirIntensity     *= (1 - nightFactor * 0.88);
    targets.ambientIntensity *= (1 - nightFactor * 0.65);
    targets.exposure          = Math.max(0.3, targets.exposure - nightFactor * 0.4);
  }

  // ---------------------------------------------------------------------------
  // Fetch weather
  // ---------------------------------------------------------------------------
  async function fetchWeather() {
    try {
      const url = buildApiUrl(currentCityKey);
      const res = await fetch(url);
      if (!res.ok) throw new Error("API responded " + res.status);
      const data = await res.json();
      updateUI(data);
    } catch (err) {
      console.error("Weather fetch failed:", err);
      document.getElementById("error-msg").style.display = "block";
      document.getElementById("error-msg").textContent = "Could not fetch weather data. Showing default scene.";
      setTimeout(() => { document.getElementById("error-msg").style.display = "none"; }, 5000);
    }
  }

  // ---------------------------------------------------------------------------
  // Animation loop
  // ---------------------------------------------------------------------------
  const clock = new THREE.Clock();
  const lerpSpeed = 0.012; // smooth transition speed

  function animate() {
    requestAnimationFrame(animate);
    const dt = clock.getDelta();
    const elapsed = clock.getElapsedTime();

    // Lerp sky palette
    const effPal = getEffectivePalette();
    lerpArr(currentPalette.top, effPal.top, lerpSpeed);
    lerpArr(currentPalette.mid, effPal.mid, lerpSpeed);
    lerpArr(currentPalette.bottom, effPal.bottom, lerpSpeed);
    applySkyColors();

    // Lerp scene properties
    const fogColor = new THREE.Color(
      (currentPalette.bottom[0] + currentPalette.mid[0]) / 2,
      (currentPalette.bottom[1] + currentPalette.mid[1]) / 2,
      (currentPalette.bottom[2] + currentPalette.mid[2]) / 2
    );
    scene.fog.color.lerp(fogColor, lerpSpeed * 2);
    scene.fog.density += (targets.fogDensity - scene.fog.density) * lerpSpeed;

    ambientLight.intensity += (targets.ambientIntensity - ambientLight.intensity) * lerpSpeed;
    dirLight.intensity += (targets.dirIntensity - dirLight.intensity) * lerpSpeed;
    dirLight.color.lerp(targets.dirColor, lerpSpeed);
    ambientLight.color.lerp(targets.ambientColor, lerpSpeed);
    renderer.toneMappingExposure += (targets.exposure - renderer.toneMappingExposure) * lerpSpeed;

    // Sun
    const sunTargetOp = targets.sunOpacity;
    sunMat.opacity += (sunTargetOp - (sunMat.opacity || 1)) * lerpSpeed;
    sunMat.opacity = sunMat.opacity || 1;
    sunMesh.visible = sunTargetOp > 0.05;
    sunMesh.position.y = 22 + Math.sin(elapsed * 0.2) * 0.5;
    sunGlow.position.copy(sunMesh.position);
    glowMat.opacity += (targets.sunGlowOpacity - glowMat.opacity) * lerpSpeed;
    sunGlow.visible = targets.sunGlowOpacity > 0.05;

    // Sun particles
    sunParticles.visible = targets.sunParticlesOpacity > 0.05;
    sunPMat.opacity += (targets.sunParticlesOpacity - sunPMat.opacity) * lerpSpeed;
    if (sunParticles.visible) {
      const sp = sunPGeo.attributes.position;
      for (let i = 0; i < SUN_P_COUNT; i++) {
        sp.setY(i, sp.getY(i) + dt * 0.3);
        if (sp.getY(i) > 25) sp.setY(i, 0);
      }
      sp.needsUpdate = true;
    }

    // Clouds movement and opacity
    cloudInstances.forEach((c) => {
      c.position.x += c.userData.speed * dt;
      if (c.position.x > 45) c.position.x = -45;
      c.children.forEach((puff) => {
        puff.material.opacity += (targets.cloudOpacity - puff.material.opacity) * lerpSpeed;
      });
    });

    // Rain
    rainSystem.visible = targets.rainOpacity > 0.05;
    rainMat.opacity += (targets.rainOpacity - rainMat.opacity) * lerpSpeed;
    if (rainSystem.visible) {
      const rp = rainGeo.attributes.position;
      for (let i = 0; i < RAIN_COUNT; i++) {
        rp.setY(i, rp.getY(i) - dt * 22);
        if (rp.getY(i) < -1) {
          rp.setY(i, 35 + Math.random() * 5);
          rp.setX(i, (Math.random() - 0.5) * 80);
          rp.setZ(i, (Math.random() - 0.5) * 60);
        }
      }
      rp.needsUpdate = true;
    }

    // Snow
    snowSystem.visible = targets.snowOpacity > 0.05;
    snowMat.opacity += (targets.snowOpacity - snowMat.opacity) * lerpSpeed;
    if (snowSystem.visible) {
      const sp2 = snowGeo.attributes.position;
      for (let i = 0; i < SNOW_COUNT; i++) {
        sp2.setY(i, sp2.getY(i) - dt * 1.8);
        sp2.setX(i, sp2.getX(i) + Math.sin(elapsed + i) * dt * 0.3);
        if (sp2.getY(i) < -1) {
          sp2.setY(i, 35 + Math.random() * 5);
          sp2.setX(i, (Math.random() - 0.5) * 80);
          sp2.setZ(i, (Math.random() - 0.5) * 60);
        }
      }
      sp2.needsUpdate = true;
    }

    // Lightning
    if (currentCondition === "thunder") {
      lightningTimer += dt;
      if (lightningTimer > nextLightning) {
        lightningLight.intensity = 5 + Math.random() * 10;
        lightningLight.position.set((Math.random() - 0.5) * 40, 20 + Math.random() * 10, -15 - Math.random() * 10);
        nextLightning = 2 + Math.random() * 6;
        lightningTimer = 0;
      }
      if (lightningLight.intensity > 0) {
        lightningLight.intensity *= 0.88;
        if (lightningLight.intensity < 0.1) lightningLight.intensity = 0;
      }
    } else {
      lightningLight.intensity *= 0.9;
    }

    // Water ripple
    for (let i = 0; i < waterPosAttr.count; i++) {
      const x = waterPosAttr.getX(i);
      const y = waterPosAttr.getY(i);
      const wave = Math.sin(x * 0.3 + elapsed * 0.8) * 0.08 +
                   Math.sin(y * 0.25 + elapsed * 0.6) * 0.06 +
                   Math.sin((x + y) * 0.2 + elapsed * 1.2) * 0.04;
      waterPosAttr.setZ(i, waterOrigY[i] + wave);
    }
    waterPosAttr.needsUpdate = true;
    waterGeo.computeVertexNormals();

    // Pedestrians
    for (const p of pedestrians) {
      p.phase += dt * p.speed * 5.5;
      p.mesh.position.x += p.dir * p.speed * dt;
      p.mesh.position.y = Math.abs(Math.sin(p.phase)) * 0.045;
      if (p.mesh.position.x > p.xMax) {
        p.mesh.position.x = p.xMax;
        p.dir = -1;
        p.mesh.rotation.y = Math.PI;
      } else if (p.mesh.position.x < p.xMin) {
        p.mesh.position.x = p.xMin;
        p.dir = 1;
        p.mesh.rotation.y = 0;
      }
    }

    // Cars
    for (const c of cars) {
      c.mesh.position.x += c.dir * c.speed * dt;
      if (c.mesh.position.x > c.xMax) c.mesh.position.x = c.xMin;
      else if (c.mesh.position.x < c.xMin) c.mesh.position.x = c.xMax;
    }

    // Boats
    for (const b of boats) {
      b.mesh.position.x += b.dir * b.speed * dt;
      if (b.mesh.position.x > b.xMax) b.mesh.position.x = b.xMin;
      else if (b.mesh.position.x < b.xMin) b.mesh.position.x = b.xMax;
      b.mesh.position.y = b.baseY + Math.sin(elapsed * 0.7 + b.mesh.position.x * 0.08) * 0.04;
    }

    // Birds
    for (const bd of birdData) {
      bd.flapPhase += dt * 3.5;
      const angle = bd.orbitPhase + elapsed * bd.orbitSpeed;
      bd.mesh.position.set(
        Math.cos(angle) * bd.orbitRadius,
        bd.heightBase + Math.sin(elapsed * 0.4 + bd.heightPhase) * bd.heightAmp,
        -17 + Math.sin(angle) * bd.orbitRadius
      );
      bd.mesh.rotation.y = -angle + Math.PI / 2;
      bd.mesh.scale.y = 1 + Math.sin(bd.flapPhase) * 0.35;
    }

    // Umbrellas — open during rain
    const umbrellaOpen = targets.rainOpacity > 0.3;
    for (const p of pedestrians) {
      if (p.mesh.userData.umbrella) p.mesh.userData.umbrella.visible = umbrellaOpen;
    }

    // Window brightness — increases at night
    const winEmissiveTarget = 0.4 + nightFactor * 1.4;
    for (const mat of allWindowMats) {
      mat.emissiveIntensity += (winEmissiveTarget - mat.emissiveIntensity) * lerpSpeed * 2;
    }

    // Stars and Moon
    const starTargetOpacity = nightFactor > 0.1 ? nightFactor * 0.9 : 0;
    starsMat.opacity += (starTargetOpacity - starsMat.opacity) * lerpSpeed * 3;
    moonMesh.material.opacity += (nightFactor * 0.92 - moonMesh.material.opacity) * lerpSpeed * 2;
    moonGlowMat.opacity += (nightFactor * 0.7 - moonGlowMat.opacity) * lerpSpeed * 2;
    moonMesh.visible = moonMesh.material.opacity > 0.01;
    moonGlow.visible = moonGlowMat.opacity > 0.01;

    // Shooting star (only at night)
    if (nightFactor > 0.7) {
      shootingStarTimer += dt;
      if (!sStarActive && shootingStarTimer > nextShootingStar) {
        sStarActive = true; sStarProgress = 0;
        sStarX0 = (Math.random() - 0.3) * 70;
        sStarY0 = 35 + Math.random() * 20;
        sStarZ0 = -40 - Math.random() * 40;
        sStarDX = (Math.random() - 0.5) * 55;
        sStarDY = -18 - Math.random() * 18;
        shootingStarTimer = 0;
        nextShootingStar = 12 + Math.random() * 20;
      }
    }
    if (sStarActive) {
      sStarProgress += dt * 2.2;
      const t = Math.min(sStarProgress, 1);
      sStarPts[0] = sStarX0 + sStarDX * Math.max(0, t - 0.12);
      sStarPts[1] = sStarY0 + sStarDY * Math.max(0, t - 0.12);
      sStarPts[2] = sStarZ0;
      sStarPts[3] = sStarX0 + sStarDX * t;
      sStarPts[4] = sStarY0 + sStarDY * t;
      sStarPts[5] = sStarZ0;
      sStarGeo.attributes.position.needsUpdate = true;
      sStarMat.opacity = t < 0.4 ? t * 2.5 : (1 - t) * 1.67;
      if (t >= 1) { sStarActive = false; sStarMat.opacity = 0; }
    }

    // Snow caps on rooftops
    const snowCapTarget = targets.snowOpacity * 0.88;
    for (const mat of snowCapMats) {
      mat.opacity += (snowCapTarget - mat.opacity) * lerpSpeed * 1.5;
    }

    // Street lamps at night
    const lampTarget = nightFactor > 0.35 ? 0.5 + nightFactor * 1.8 : 0;
    for (const mat of lampBulbMats) {
      mat.emissiveIntensity += (lampTarget - mat.emissiveIntensity) * lerpSpeed * 3;
    }
    // Ground light pools under lamps
    const poolTarget = nightFactor > 0.35 ? nightFactor * 0.18 : 0;
    for (const mat of lampPoolMats) {
      mat.opacity += (poolTarget - mat.opacity) * lerpSpeed * 3;
    }
    // Car headlight road beams
    const beamTarget = nightFactor > 0.35 ? 0.08 + nightFactor * 0.18 : 0;
    for (const c of cars) {
      if (c.beamMat) c.beamMat.opacity += (beamTarget - c.beamMat.opacity) * lerpSpeed * 3;
    }

    // Neon signs at night
    if (nightFactor > 0.2) {
      for (const n of neonSignData) {
        n.flickerPhase += dt * n.flickerSpeed;
        const flicker = 0.88 + Math.sin(n.flickerPhase) * 0.08 + Math.sin(n.flickerPhase * 3.7) * 0.04;
        const neonTarget = nightFactor * 2.8 * flicker;
        n.mat.emissiveIntensity += (neonTarget - n.mat.emissiveIntensity) * 0.06;
      }
    } else {
      for (const n of neonSignData) {
        n.mat.emissiveIntensity *= 0.94;
      }
    }

    // Flags — wave based on wind speed
    const windAmp = Math.min(currentWindSpeed / 45, 0.55);
    for (const f of flagData) {
      const pos = f.geo.attributes.position;
      for (let i = 0; i < pos.count; i++) {
        const localX = pos.getX(i);
        const u = (localX + 0.7) / 1.4;
        pos.setZ(i, Math.sin(elapsed * 4.5 + u * 5.5) * windAmp * u * 0.5);
      }
      pos.needsUpdate = true;
    }

    // Mexico City muzzle flashes
    if (currentCityKey === 'mexico-city') {
      for (const f of mxFlashMats) {
        f.timer -= dt;
        if (f.timer <= 0) {
          f.mat.emissiveIntensity = 5 + Math.random() * 8;
          f.timer = 0.6 + Math.random() * 2.2;
        } else {
          f.mat.emissiveIntensity *= 0.72;
        }
      }
    }

    // Gentle camera sway
    camera.position.x = Math.sin(elapsed * 0.08) * 1.5;
    camera.position.y = 6 + Math.sin(elapsed * 0.12) * 0.4;
    camera.lookAt(0, 4, -5);

    renderer.render(scene, camera);
  }

  // ---------------------------------------------------------------------------
  // Resize handler
  // ---------------------------------------------------------------------------
  window.addEventListener("resize", () => {
    camera.aspect = innerWidth / innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(innerWidth, innerHeight);
  });

  // ---------------------------------------------------------------------------
  // City picker logic
  // ---------------------------------------------------------------------------
  const cityPicker = document.getElementById("city-picker");
  let isSwitchingCity = false;

  cityPicker.addEventListener("change", async function () {
    if (isSwitchingCity) return;
    isSwitchingCity = true;

    const newCityKey = this.value;
    if (newCityKey === currentCityKey) {
      isSwitchingCity = false;
      return;
    }

    currentCityKey = newCityKey;

    // Brief fade-out on the weather overlay for a smooth visual transition
    const overlay = document.getElementById("weather-overlay");
    overlay.classList.add("switching");

    await fetchWeather();
    switchCityVisuals(newCityKey);

    // Restore overlay after data loads
    // Small delay to ensure the switching class transition completes
    setTimeout(() => {
      overlay.classList.remove("switching");
      isSwitchingCity = false;
    }, 100);
  });

  // ---------------------------------------------------------------------------
  // Boot
  // ---------------------------------------------------------------------------
  async function init() {
    await fetchWeather();

    // Dismiss loading screen
    const loadEl = document.getElementById("loading");
    loadEl.classList.add("fade-out");
    setTimeout(() => loadEl.remove(), 900);

    // Show overlay and city picker
    document.getElementById("weather-overlay").classList.add("visible");
    document.getElementById("timestamp").classList.add("visible");
    document.getElementById("city-picker-container").classList.add("visible");

    animate();

    // Refresh weather every 10 minutes
    setInterval(fetchWeather, 10 * 60 * 1000);
  }

  init();
})();
</script>

<a href="https://github.com/MojtabaTajik" target="_blank" rel="noopener"
   style="position:fixed;bottom:1.2rem;right:1.4rem;z-index:100;display:flex;align-items:center;gap:0.45rem;text-decoration:none;color:rgba(255,255,255,0.45);font-family:'Segoe UI',system-ui,sans-serif;font-size:0.75rem;letter-spacing:0.04em;transition:color 0.2s"
   onmouseover="this.style.color='rgba(255,255,255,0.9)'" onmouseout="this.style.color='rgba(255,255,255,0.45)'">
  <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor">
    <path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0 0 24 12c0-6.63-5.37-12-12-12z"/>
  </svg>
  MojtabaTajik
</a>
</body>
</html>
